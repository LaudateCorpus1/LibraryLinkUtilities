<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LibraryLink Utilities: LLU::MArgumentManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:600" rel="stylesheet">
<script src="striped_bg.js"></script>
<link href="style.css" rel="stylesheet" type="text/css"/>
<link href="style.css.map" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LLULogo_144.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LibraryLink Utilities
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Modern C++ wrapper over LibraryLink and WSTP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classLLU_1_1MArgumentManager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classLLU_1_1MArgumentManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LLU::MArgumentManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Manages arguments exchanged between the paclet C++ code and LibraryLink interface. </p>
<p><a class="el" href="classLLU_1_1MArgumentManager.html" title="Manages arguments exchanged between the paclet C++ code and LibraryLink interface.">MArgumentManager</a> provides a safe way to access MArguments received from LibraryLink and takes care of memory management both for in- and out- arguments. Using <a class="el" href="classLLU_1_1MArgumentManager.html" title="Manages arguments exchanged between the paclet C++ code and LibraryLink interface.">MArgumentManager</a> one can perform generic operations on NumericArrays, Tensors and Images independent of their data type. </p>
</div>
<p><code>#include &lt;<a class="el" href="MArgumentManager_8h_source.html">MArgumentManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1MArgumentManager_1_1CustomType.html">CustomType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure that can be used to register user-defined argument types in <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a>.  <a href="structLLU_1_1MArgumentManager_1_1CustomType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1MArgumentManager_1_1Getter.html">Getter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure to fully customize the way <a class="el" href="classLLU_1_1MArgumentManager.html" title="Manages arguments exchanged between the paclet C++ code and LibraryLink interface.">MArgumentManager</a> reads T as argument type.  <a href="structLLU_1_1MArgumentManager_1_1Getter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html">Managed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to "attach" a passing mode to container type when passing it as template argument to <a class="el" href="classLLU_1_1MArgumentManager.html#a5416b32de02b012ad4ada580badf2791" title="Extract arguments from the Manager and return them as values of given types.">MArgumentManager::getTuple</a>.  <a href="structLLU_1_1MArgumentManager_1_1Managed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1MArgumentManager_1_1Setter.html">Setter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure to fully customize the way <a class="el" href="classLLU_1_1MArgumentManager.html" title="Manages arguments exchanged between the paclet C++ code and LibraryLink interface.">MArgumentManager</a> sets an object of type T as result of a library function.  <a href="structLLU_1_1MArgumentManager_1_1Setter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a99eeec737c914999dc13bf945fd5b3d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a99eeec737c914999dc13bf945fd5b3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type for indexing the list of arguments that <a class="el" href="classLLU_1_1MArgumentManager.html" title="Manages arguments exchanged between the paclet C++ code and LibraryLink interface.">MArgumentManager</a> manages.  <a href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">More...</a><br /></td></tr>
<tr class="separator:a99eeec737c914999dc13bf945fd5b3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501e118c237c8d86d944028b974451e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a501e118c237c8d86d944028b974451e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">RequestedType</a> = typename RequestedTypeImpl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a501e118c237c8d86d944028b974451e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">RequestedType&lt;T&gt; is usually just T and is used as return type of MArgumentManager::get(size_type)  <a href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">More...</a><br /></td></tr>
<tr class="separator:a501e118c237c8d86d944028b974451e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0fb2b3e343ef1f6bc2734fc1d5c0f198"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a0fb2b3e343ef1f6bc2734fc1d5c0f198">MArgumentManager</a> (mint Argc, MArgument *Args, MArgument &amp;Res)</td></tr>
<tr class="memdesc:a0fb2b3e343ef1f6bc2734fc1d5c0f198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classLLU_1_1MArgumentManager.html#a0fb2b3e343ef1f6bc2734fc1d5c0f198">More...</a><br /></td></tr>
<tr class="separator:a0fb2b3e343ef1f6bc2734fc1d5c0f198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290a9939e31c44d370bf560ea3ada1a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a290a9939e31c44d370bf560ea3ada1a2">MArgumentManager</a> (WolframLibraryData ld, mint Argc, MArgument *Args, MArgument &amp;Res)</td></tr>
<tr class="memdesc:a290a9939e31c44d370bf560ea3ada1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classLLU_1_1MArgumentManager.html#a290a9939e31c44d370bf560ea3ada1a2">More...</a><br /></td></tr>
<tr class="separator:a290a9939e31c44d370bf560ea3ada1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05484aa8782e4b0e550366780433200"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ac05484aa8782e4b0e550366780433200">getBoolean</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:ac05484aa8782e4b0e550366780433200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type <b>mbool</b> at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#ac05484aa8782e4b0e550366780433200">More...</a><br /></td></tr>
<tr class="separator:ac05484aa8782e4b0e550366780433200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72bb31d4f4b681edc66224495105ee8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ac72bb31d4f4b681edc66224495105ee8">getReal</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:ac72bb31d4f4b681edc66224495105ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type <b>mreal</b> at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#ac72bb31d4f4b681edc66224495105ee8">More...</a><br /></td></tr>
<tr class="separator:ac72bb31d4f4b681edc66224495105ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd7cfb82e338e2f7d0e04c1423cfb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3bd7cfb82e338e2f7d0e04c1423cfb9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#aa3bd7cfb82e338e2f7d0e04c1423cfb9">getInteger</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:aa3bd7cfb82e338e2f7d0e04c1423cfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type <b>mint</b> at position <code>index</code> with extra static_cast if needed.  <a href="classLLU_1_1MArgumentManager.html#aa3bd7cfb82e338e2f7d0e04c1423cfb9">More...</a><br /></td></tr>
<tr class="separator:aa3bd7cfb82e338e2f7d0e04c1423cfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db1878ff9e9e35f6f63117d686e63b9"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a8db1878ff9e9e35f6f63117d686e63b9">getComplex</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a8db1878ff9e9e35f6f63117d686e63b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type <b>mcomplex</b> at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#a8db1878ff9e9e35f6f63117d686e63b9">More...</a><br /></td></tr>
<tr class="separator:a8db1878ff9e9e35f6f63117d686e63b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f41521d97f42fc7797f698d5b227e9"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ac1f41521d97f42fc7797f698d5b227e9">getCString</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:ac1f41521d97f42fc7797f698d5b227e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of MArgument of type <b>"UTF8String"</b> at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#ac1f41521d97f42fc7797f698d5b227e9">More...</a><br /></td></tr>
<tr class="separator:ac1f41521d97f42fc7797f698d5b227e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75704183d6d6f3143652c6f6e55c00e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ae75704183d6d6f3143652c6f6e55c00e">getString</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:ae75704183d6d6f3143652c6f6e55c00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of MArgument of type <b>"UTF8String"</b> at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#ae75704183d6d6f3143652c6f6e55c00e">More...</a><br /></td></tr>
<tr class="separator:ae75704183d6d6f3143652c6f6e55c00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9208b7904e478bd88b2518713a74a7b"><td class="memTemplParams" colspan="2">template&lt;typename T , Passing Mode = Passing::Automatic&gt; </td></tr>
<tr class="memitem:ae9208b7904e478bd88b2518713a74a7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLLU_1_1NumericArray.html">NumericArray</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ae9208b7904e478bd88b2518713a74a7b">getNumericArray</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:ae9208b7904e478bd88b2518713a74a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MNumericArray at position <code>index</code> and wrap it into <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a>.  <a href="classLLU_1_1MArgumentManager.html#ae9208b7904e478bd88b2518713a74a7b">More...</a><br /></td></tr>
<tr class="separator:ae9208b7904e478bd88b2518713a74a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a9b6e0b93f2f1fb3fdc1ad1cc28ad6"><td class="memTemplParams" colspan="2">template&lt;Passing Mode = Passing::Automatic&gt; </td></tr>
<tr class="memitem:a58a9b6e0b93f2f1fb3fdc1ad1cc28ad6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceLLU.html#ac246fc9334d25bf0df9d08f0bfb8927d">GenericNumericArray</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a58a9b6e0b93f2f1fb3fdc1ad1cc28ad6">getGenericNumericArray</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a58a9b6e0b93f2f1fb3fdc1ad1cc28ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MNumericArray at position <code>index</code> and wrap it into generic <a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper.  <a href="classLLU_1_1MArgumentManager.html#a58a9b6e0b93f2f1fb3fdc1ad1cc28ad6">More...</a><br /></td></tr>
<tr class="separator:a58a9b6e0b93f2f1fb3fdc1ad1cc28ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec27fba3c06c10754485ee987786e3d"><td class="memItemLeft" align="right" valign="top">MNumericArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#abec27fba3c06c10754485ee987786e3d">getMNumericArray</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:abec27fba3c06c10754485ee987786e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MNumericArray at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#abec27fba3c06c10754485ee987786e3d">More...</a><br /></td></tr>
<tr class="separator:abec27fba3c06c10754485ee987786e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5170d482d1adb7d5204b74f4647af2"><td class="memTemplParams" colspan="2">template&lt;typename T , Passing Mode = Passing::Automatic&gt; </td></tr>
<tr class="memitem:a5a5170d482d1adb7d5204b74f4647af2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLLU_1_1Tensor.html">Tensor</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a5a5170d482d1adb7d5204b74f4647af2">getTensor</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a5a5170d482d1adb7d5204b74f4647af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MTensor at position <code>index</code> and wrap it into <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> object.  <a href="classLLU_1_1MArgumentManager.html#a5a5170d482d1adb7d5204b74f4647af2">More...</a><br /></td></tr>
<tr class="separator:a5a5170d482d1adb7d5204b74f4647af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fb955aaa75872ec84a628b1961b009"><td class="memTemplParams" colspan="2">template&lt;Passing Mode = Passing::Automatic&gt; </td></tr>
<tr class="memitem:a42fb955aaa75872ec84a628b1961b009"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceLLU.html#aa463b81b42bbdd7c6fb53e32132e0a2f">GenericTensor</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a42fb955aaa75872ec84a628b1961b009">getGenericTensor</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a42fb955aaa75872ec84a628b1961b009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MTensor at position <code>index</code> and wrap it into generic <a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper.  <a href="classLLU_1_1MArgumentManager.html#a42fb955aaa75872ec84a628b1961b009">More...</a><br /></td></tr>
<tr class="separator:a42fb955aaa75872ec84a628b1961b009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827f6f1a8c5b7b75ce1df7f8959182ab"><td class="memItemLeft" align="right" valign="top">MTensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a827f6f1a8c5b7b75ce1df7f8959182ab">getMTensor</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a827f6f1a8c5b7b75ce1df7f8959182ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MTensor at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#a827f6f1a8c5b7b75ce1df7f8959182ab">More...</a><br /></td></tr>
<tr class="separator:a827f6f1a8c5b7b75ce1df7f8959182ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86f91cdfe25094a523b4c585f6b6265"><td class="memTemplParams" colspan="2">template&lt;typename T , Passing Mode = Passing::Automatic&gt; </td></tr>
<tr class="memitem:ab86f91cdfe25094a523b4c585f6b6265"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLLU_1_1Image.html">Image</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ab86f91cdfe25094a523b4c585f6b6265">getImage</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:ab86f91cdfe25094a523b4c585f6b6265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MImage at position <code>index</code> and wrap it into <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> object.  <a href="classLLU_1_1MArgumentManager.html#ab86f91cdfe25094a523b4c585f6b6265">More...</a><br /></td></tr>
<tr class="separator:ab86f91cdfe25094a523b4c585f6b6265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004b0cb543254f8ad1625e3c6fa9d4a2"><td class="memTemplParams" colspan="2">template&lt;Passing Mode = Passing::Automatic&gt; </td></tr>
<tr class="memitem:a004b0cb543254f8ad1625e3c6fa9d4a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceLLU.html#a7013557ff73aaad19a9a5411520be837">GenericImage</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a004b0cb543254f8ad1625e3c6fa9d4a2">getGenericImage</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a004b0cb543254f8ad1625e3c6fa9d4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MImage at position <code>index</code> and wrap it into generic <a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper.  <a href="classLLU_1_1MArgumentManager.html#a004b0cb543254f8ad1625e3c6fa9d4a2">More...</a><br /></td></tr>
<tr class="separator:a004b0cb543254f8ad1625e3c6fa9d4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13a505910535cdc17f33f5632c4421a"><td class="memItemLeft" align="right" valign="top">MImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ac13a505910535cdc17f33f5632c4421a">getMImage</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:ac13a505910535cdc17f33f5632c4421a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type MImage at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#ac13a505910535cdc17f33f5632c4421a">More...</a><br /></td></tr>
<tr class="separator:ac13a505910535cdc17f33f5632c4421a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44796732a9facd368d49ac9ae1298a27"><td class="memTemplParams" colspan="2">template&lt;typename T , Passing Mode = Passing::Automatic&gt; </td></tr>
<tr class="memitem:a44796732a9facd368d49ac9ae1298a27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLLU_1_1DataList.html">DataList</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a44796732a9facd368d49ac9ae1298a27">getDataList</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a44796732a9facd368d49ac9ae1298a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DataStore with all nodes of the same type from MArgument at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#a44796732a9facd368d49ac9ae1298a27">More...</a><br /></td></tr>
<tr class="separator:a44796732a9facd368d49ac9ae1298a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68defdac36d7d6f3f109cd22b23f60b"><td class="memTemplParams" colspan="2">template&lt;Passing Mode = Passing::Automatic&gt; </td></tr>
<tr class="memitem:ac68defdac36d7d6f3f109cd22b23f60b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceLLU.html#a4a9e8e31bf555d15928845a173704aa9">GenericDataList</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ac68defdac36d7d6f3f109cd22b23f60b">getGenericDataList</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:ac68defdac36d7d6f3f109cd22b23f60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type DataStore at position <code>index</code> and wrap it into generic <a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper.  <a href="classLLU_1_1MArgumentManager.html#ac68defdac36d7d6f3f109cd22b23f60b">More...</a><br /></td></tr>
<tr class="separator:ac68defdac36d7d6f3f109cd22b23f60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919afbc251bf7949250e58f36a6ac2db"><td class="memItemLeft" align="right" valign="top">DataStore&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a919afbc251bf7949250e58f36a6ac2db">getDataStore</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a919afbc251bf7949250e58f36a6ac2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get MArgument of type DataStore at position <code>index</code>.  <a href="classLLU_1_1MArgumentManager.html#a919afbc251bf7949250e58f36a6ac2db">More...</a><br /></td></tr>
<tr class="separator:a919afbc251bf7949250e58f36a6ac2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0e0d89b51e3ecebb05af6c96418893"><td class="memTemplParams" colspan="2">template&lt;class ManagedExpr , class DynamicType  = ManagedExpr&gt; </td></tr>
<tr class="memitem:a8c0e0d89b51e3ecebb05af6c96418893"><td class="memTemplItemLeft" align="right" valign="top">DynamicType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a8c0e0d89b51e3ecebb05af6c96418893">getManagedExpression</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index, <a class="el" href="classLLU_1_1ManagedExpressionStore.html">ManagedExpressionStore</a>&lt; ManagedExpr &gt; &amp;store) const</td></tr>
<tr class="memdesc:a8c0e0d89b51e3ecebb05af6c96418893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an instance of <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression that was sent from Wolfram Language as argument to a library function.  <a href="classLLU_1_1MArgumentManager.html#a8c0e0d89b51e3ecebb05af6c96418893">More...</a><br /></td></tr>
<tr class="separator:a8c0e0d89b51e3ecebb05af6c96418893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b8c02c826fa0ee95ed8a9937ec6345"><td class="memTemplParams" colspan="2">template&lt;class ManagedExpr , class DynamicType  = ManagedExpr&gt; </td></tr>
<tr class="memitem:af2b8c02c826fa0ee95ed8a9937ec6345"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; DynamicType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#af2b8c02c826fa0ee95ed8a9937ec6345">getManagedExpressionPtr</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index, <a class="el" href="classLLU_1_1ManagedExpressionStore.html">ManagedExpressionStore</a>&lt; ManagedExpr &gt; &amp;store) const</td></tr>
<tr class="memdesc:af2b8c02c826fa0ee95ed8a9937ec6345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to an instance of <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression that was sent from Wolfram Language as argument to a library function.  <a href="classLLU_1_1MArgumentManager.html#af2b8c02c826fa0ee95ed8a9937ec6345">More...</a><br /></td></tr>
<tr class="separator:af2b8c02c826fa0ee95ed8a9937ec6345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a58218d6199891564ea692da4a225e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a58218d6199891564ea692da4a225e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">RequestedType</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a5a58218d6199891564ea692da4a225e4">get</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a5a58218d6199891564ea692da4a225e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract library function argument at given index and convert it from MArgument to a desired type.  <a href="classLLU_1_1MArgumentManager.html#a5a58218d6199891564ea692da4a225e4">More...</a><br /></td></tr>
<tr class="separator:a5a58218d6199891564ea692da4a225e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416b32de02b012ad4ada580badf2791"><td class="memTemplParams" colspan="2">template&lt;typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a5416b32de02b012ad4ada580badf2791"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">RequestedType</a>&lt; ArgTypes &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a5416b32de02b012ad4ada580badf2791">getTuple</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index=0) const</td></tr>
<tr class="memdesc:a5416b32de02b012ad4ada580badf2791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract arguments from the Manager and return them as values of given types.  <a href="classLLU_1_1MArgumentManager.html#a5416b32de02b012ad4ada580badf2791">More...</a><br /></td></tr>
<tr class="separator:a5416b32de02b012ad4ada580badf2791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5149865c418e41356221edbcdeac9e7d"><td class="memTemplParams" colspan="2">template&lt;typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a5149865c418e41356221edbcdeac9e7d"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">RequestedType</a>&lt; ArgTypes &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a5149865c418e41356221edbcdeac9e7d">getTuple</a> (std::array&lt; <a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>, sizeof...(ArgTypes)&gt; indices) const</td></tr>
<tr class="memdesc:a5149865c418e41356221edbcdeac9e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract arguments from the Manager at given positions and return them as values of given types.  <a href="classLLU_1_1MArgumentManager.html#a5149865c418e41356221edbcdeac9e7d">More...</a><br /></td></tr>
<tr class="separator:a5149865c418e41356221edbcdeac9e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6df0fce424f60f9bd8348aad29b3593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ac6df0fce424f60f9bd8348aad29b3593">setBoolean</a> (bool result) noexcept</td></tr>
<tr class="memdesc:ac6df0fce424f60f9bd8348aad29b3593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>result</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#ac6df0fce424f60f9bd8348aad29b3593">More...</a><br /></td></tr>
<tr class="separator:ac6df0fce424f60f9bd8348aad29b3593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039b2c94af57cbb77f71ddf1b5e5b35a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a039b2c94af57cbb77f71ddf1b5e5b35a">setReal</a> (double result) noexcept</td></tr>
<tr class="memdesc:a039b2c94af57cbb77f71ddf1b5e5b35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>result</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a039b2c94af57cbb77f71ddf1b5e5b35a">More...</a><br /></td></tr>
<tr class="separator:a039b2c94af57cbb77f71ddf1b5e5b35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef09c1ee1bb3336f088157ea2267b532"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#aef09c1ee1bb3336f088157ea2267b532">setInteger</a> (mint result) noexcept</td></tr>
<tr class="memdesc:aef09c1ee1bb3336f088157ea2267b532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>result</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#aef09c1ee1bb3336f088157ea2267b532">More...</a><br /></td></tr>
<tr class="separator:aef09c1ee1bb3336f088157ea2267b532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd058a68f5ce18867c1d70450a45e12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adcd058a68f5ce18867c1d70450a45e12"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#adcd058a68f5ce18867c1d70450a45e12">setMintAndCheck</a> (T result) noexcept</td></tr>
<tr class="memdesc:adcd058a68f5ce18867c1d70450a45e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>result</code> as output MArgument and check for overflow.  <a href="classLLU_1_1MArgumentManager.html#adcd058a68f5ce18867c1d70450a45e12">More...</a><br /></td></tr>
<tr class="separator:adcd058a68f5ce18867c1d70450a45e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03025301159406fcc28fbf75012d6459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a03025301159406fcc28fbf75012d6459">setComplex</a> (std::complex&lt; double &gt; c) noexcept</td></tr>
<tr class="memdesc:a03025301159406fcc28fbf75012d6459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>c</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a03025301159406fcc28fbf75012d6459">More...</a><br /></td></tr>
<tr class="separator:a03025301159406fcc28fbf75012d6459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a2d2be982f1e9f89579d95a1d3918a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a79a2d2be982f1e9f89579d95a1d3918a">setString</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a79a2d2be982f1e9f89579d95a1d3918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>str</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a79a2d2be982f1e9f89579d95a1d3918a">More...</a><br /></td></tr>
<tr class="separator:a79a2d2be982f1e9f89579d95a1d3918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc510cab97269d495321d09ebad7126e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#afc510cab97269d495321d09ebad7126e">setString</a> (const char *str)</td></tr>
<tr class="memdesc:afc510cab97269d495321d09ebad7126e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classLLU_1_1MArgumentManager.html#afc510cab97269d495321d09ebad7126e">More...</a><br /></td></tr>
<tr class="separator:afc510cab97269d495321d09ebad7126e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976fe7c259133c788bdd8916d2f78e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a976fe7c259133c788bdd8916d2f78e7e">setString</a> (std::string &amp;&amp;str)</td></tr>
<tr class="memdesc:a976fe7c259133c788bdd8916d2f78e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="classLLU_1_1MArgumentManager.html#a976fe7c259133c788bdd8916d2f78e7e">More...</a><br /></td></tr>
<tr class="separator:a976fe7c259133c788bdd8916d2f78e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205ad433b345687c1ed15aba4782a9e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a205ad433b345687c1ed15aba4782a9e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a205ad433b345687c1ed15aba4782a9e5">setNumericArray</a> (const <a class="el" href="classLLU_1_1NumericArray.html">NumericArray</a>&lt; T &gt; &amp;na)</td></tr>
<tr class="memdesc:a205ad433b345687c1ed15aba4782a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MNumericArray wrapped by <code>na</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a205ad433b345687c1ed15aba4782a9e5">More...</a><br /></td></tr>
<tr class="separator:a205ad433b345687c1ed15aba4782a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206866cdaa619f4a25b5acd628797dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a206866cdaa619f4a25b5acd628797dcb">setMNumericArray</a> (MNumericArray na)</td></tr>
<tr class="memdesc:a206866cdaa619f4a25b5acd628797dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MNumericArray as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a206866cdaa619f4a25b5acd628797dcb">More...</a><br /></td></tr>
<tr class="separator:a206866cdaa619f4a25b5acd628797dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a55b48a13fdaa532b50cff7bf294b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0a55b48a13fdaa532b50cff7bf294b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ab0a55b48a13fdaa532b50cff7bf294b3">setTensor</a> (const <a class="el" href="classLLU_1_1Tensor.html">Tensor</a>&lt; T &gt; &amp;ten)</td></tr>
<tr class="memdesc:ab0a55b48a13fdaa532b50cff7bf294b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MTensor wrapped by <code>ten</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#ab0a55b48a13fdaa532b50cff7bf294b3">More...</a><br /></td></tr>
<tr class="separator:ab0a55b48a13fdaa532b50cff7bf294b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85b070a81792c9b7d776930262606a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#af85b070a81792c9b7d776930262606a7">setMTensor</a> (MTensor t)</td></tr>
<tr class="memdesc:af85b070a81792c9b7d776930262606a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MTensor as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#af85b070a81792c9b7d776930262606a7">More...</a><br /></td></tr>
<tr class="separator:af85b070a81792c9b7d776930262606a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14abe54f5e863363775637cb9818c14a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14abe54f5e863363775637cb9818c14a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a14abe54f5e863363775637cb9818c14a">setImage</a> (const <a class="el" href="classLLU_1_1Image.html">Image</a>&lt; T &gt; &amp;im)</td></tr>
<tr class="memdesc:a14abe54f5e863363775637cb9818c14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MImage wrapped by <code>im</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a14abe54f5e863363775637cb9818c14a">More...</a><br /></td></tr>
<tr class="separator:a14abe54f5e863363775637cb9818c14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48f2a3f8e4f852ac9e13af51e17fd74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ad48f2a3f8e4f852ac9e13af51e17fd74">setMImage</a> (MImage im)</td></tr>
<tr class="memdesc:ad48f2a3f8e4f852ac9e13af51e17fd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MImage as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#ad48f2a3f8e4f852ac9e13af51e17fd74">More...</a><br /></td></tr>
<tr class="separator:ad48f2a3f8e4f852ac9e13af51e17fd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c18a2b2af22583744f01bfcf6a3e46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11c18a2b2af22583744f01bfcf6a3e46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a11c18a2b2af22583744f01bfcf6a3e46">setDataList</a> (const <a class="el" href="classLLU_1_1DataList.html">DataList</a>&lt; T &gt; &amp;ds)</td></tr>
<tr class="memdesc:a11c18a2b2af22583744f01bfcf6a3e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set DataStore wrapped in <a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> <code>ds</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a11c18a2b2af22583744f01bfcf6a3e46">More...</a><br /></td></tr>
<tr class="separator:a11c18a2b2af22583744f01bfcf6a3e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aa5c17a67b7f604952f3467829305a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a90aa5c17a67b7f604952f3467829305a">setDataStore</a> (DataStore ds)</td></tr>
<tr class="memdesc:a90aa5c17a67b7f604952f3467829305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set DataStore as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a90aa5c17a67b7f604952f3467829305a">More...</a><br /></td></tr>
<tr class="separator:a90aa5c17a67b7f604952f3467829305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335c472c1f964b634ac36948efb74b4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a335c472c1f964b634ac36948efb74b4b">setSparseArray</a> (MSparseArray sa)</td></tr>
<tr class="memdesc:a335c472c1f964b634ac36948efb74b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MSparseArray as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a335c472c1f964b634ac36948efb74b4b">More...</a><br /></td></tr>
<tr class="separator:a335c472c1f964b634ac36948efb74b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace962bd6a20d9879b1a35b4c1a276970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ace962bd6a20d9879b1a35b4c1a276970">set</a> (bool result) noexcept</td></tr>
<tr class="memdesc:ace962bd6a20d9879b1a35b4c1a276970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>result</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#ace962bd6a20d9879b1a35b4c1a276970">More...</a><br /></td></tr>
<tr class="separator:ace962bd6a20d9879b1a35b4c1a276970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2048dfd36c3ae75a06cd55fe23b54fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a2048dfd36c3ae75a06cd55fe23b54fb8">set</a> (double result) noexcept</td></tr>
<tr class="memdesc:a2048dfd36c3ae75a06cd55fe23b54fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>result</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a2048dfd36c3ae75a06cd55fe23b54fb8">More...</a><br /></td></tr>
<tr class="separator:a2048dfd36c3ae75a06cd55fe23b54fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36018287bd3701493f70ebd4b1378f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#af36018287bd3701493f70ebd4b1378f9">set</a> (mint result) noexcept</td></tr>
<tr class="memdesc:af36018287bd3701493f70ebd4b1378f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>result</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#af36018287bd3701493f70ebd4b1378f9">More...</a><br /></td></tr>
<tr class="separator:af36018287bd3701493f70ebd4b1378f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc9e93fd301924266866b25bd18b130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a7bc9e93fd301924266866b25bd18b130">set</a> (std::complex&lt; double &gt; c) noexcept</td></tr>
<tr class="memdesc:a7bc9e93fd301924266866b25bd18b130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>c</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a7bc9e93fd301924266866b25bd18b130">More...</a><br /></td></tr>
<tr class="separator:a7bc9e93fd301924266866b25bd18b130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dcb45ec505ca4d4b99b8b44e4bebe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a31dcb45ec505ca4d4b99b8b44e4bebe7">set</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a31dcb45ec505ca4d4b99b8b44e4bebe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>str</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a31dcb45ec505ca4d4b99b8b44e4bebe7">More...</a><br /></td></tr>
<tr class="separator:a31dcb45ec505ca4d4b99b8b44e4bebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a1e1cbc652ba634aef208cd86dfda2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a94a1e1cbc652ba634aef208cd86dfda2">set</a> (const char *str)</td></tr>
<tr class="memdesc:a94a1e1cbc652ba634aef208cd86dfda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>str</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a94a1e1cbc652ba634aef208cd86dfda2">More...</a><br /></td></tr>
<tr class="separator:a94a1e1cbc652ba634aef208cd86dfda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84c4cfea5a3a0fb50f9958d8d0d8c62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ac84c4cfea5a3a0fb50f9958d8d0d8c62">set</a> (std::string &amp;&amp;str)</td></tr>
<tr class="memdesc:ac84c4cfea5a3a0fb50f9958d8d0d8c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <code>str</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#ac84c4cfea5a3a0fb50f9958d8d0d8c62">More...</a><br /></td></tr>
<tr class="separator:ac84c4cfea5a3a0fb50f9958d8d0d8c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc82b183bd2e3b2a05cb55da61ed7da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bc82b183bd2e3b2a05cb55da61ed7da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a4bc82b183bd2e3b2a05cb55da61ed7da">set</a> (const <a class="el" href="classLLU_1_1NumericArray.html">NumericArray</a>&lt; T &gt; &amp;na)</td></tr>
<tr class="memdesc:a4bc82b183bd2e3b2a05cb55da61ed7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MNumericArray wrapped by <code>na</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a4bc82b183bd2e3b2a05cb55da61ed7da">More...</a><br /></td></tr>
<tr class="separator:a4bc82b183bd2e3b2a05cb55da61ed7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793a666bd5ab710f43d71b278dcfcd18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a793a666bd5ab710f43d71b278dcfcd18">set</a> (const <a class="el" href="namespaceLLU.html#ac246fc9334d25bf0df9d08f0bfb8927d">GenericNumericArray</a> &amp;na)</td></tr>
<tr class="memdesc:a793a666bd5ab710f43d71b278dcfcd18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MNumericArray wrapped by <code>na</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a793a666bd5ab710f43d71b278dcfcd18">More...</a><br /></td></tr>
<tr class="separator:a793a666bd5ab710f43d71b278dcfcd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8469a36c03ec66b0f0324da25ca141"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f8469a36c03ec66b0f0324da25ca141"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a4f8469a36c03ec66b0f0324da25ca141">set</a> (const <a class="el" href="classLLU_1_1Tensor.html">Tensor</a>&lt; T &gt; &amp;ten)</td></tr>
<tr class="memdesc:a4f8469a36c03ec66b0f0324da25ca141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MTensor wrapped by <code>ten</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a4f8469a36c03ec66b0f0324da25ca141">More...</a><br /></td></tr>
<tr class="separator:a4f8469a36c03ec66b0f0324da25ca141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c44095e8d5ddce1cf723c6b7440e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ad7c44095e8d5ddce1cf723c6b7440e20">set</a> (const <a class="el" href="namespaceLLU.html#aa463b81b42bbdd7c6fb53e32132e0a2f">GenericTensor</a> &amp;t)</td></tr>
<tr class="memdesc:ad7c44095e8d5ddce1cf723c6b7440e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MTensor wrapped by <code>t</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#ad7c44095e8d5ddce1cf723c6b7440e20">More...</a><br /></td></tr>
<tr class="separator:ad7c44095e8d5ddce1cf723c6b7440e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f76f2b5f063a04c59785b74eaac249"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46f76f2b5f063a04c59785b74eaac249"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a46f76f2b5f063a04c59785b74eaac249">set</a> (const <a class="el" href="classLLU_1_1Image.html">Image</a>&lt; T &gt; &amp;im)</td></tr>
<tr class="memdesc:a46f76f2b5f063a04c59785b74eaac249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MImage wrapped by <code>im</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a46f76f2b5f063a04c59785b74eaac249">More...</a><br /></td></tr>
<tr class="separator:a46f76f2b5f063a04c59785b74eaac249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4c43ca5b936af4ec25beb6833187dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a4e4c43ca5b936af4ec25beb6833187dd">set</a> (const <a class="el" href="namespaceLLU.html#a7013557ff73aaad19a9a5411520be837">GenericImage</a> &amp;im)</td></tr>
<tr class="memdesc:a4e4c43ca5b936af4ec25beb6833187dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MImage wrapped by <code>im</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a4e4c43ca5b936af4ec25beb6833187dd">More...</a><br /></td></tr>
<tr class="separator:a4e4c43ca5b936af4ec25beb6833187dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5734eef8e00e88097ec62d04afca3b72"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5734eef8e00e88097ec62d04afca3b72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a5734eef8e00e88097ec62d04afca3b72">set</a> (const <a class="el" href="classLLU_1_1DataList.html">DataList</a>&lt; T &gt; &amp;ds)</td></tr>
<tr class="memdesc:a5734eef8e00e88097ec62d04afca3b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set DataStore wrapped in <a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> <code>ds</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a5734eef8e00e88097ec62d04afca3b72">More...</a><br /></td></tr>
<tr class="separator:a5734eef8e00e88097ec62d04afca3b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1e87824053e944c082d65220f1a4fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a9c1e87824053e944c082d65220f1a4fb">set</a> (const <a class="el" href="namespaceLLU.html#a4a9e8e31bf555d15928845a173704aa9">GenericDataList</a> &amp;ds)</td></tr>
<tr class="memdesc:a9c1e87824053e944c082d65220f1a4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set DataStore wrapped by <code>ds</code> as output MArgument.  <a href="classLLU_1_1MArgumentManager.html#a9c1e87824053e944c082d65220f1a4fb">More...</a><br /></td></tr>
<tr class="separator:a9c1e87824053e944c082d65220f1a4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a68c6f219c6ba63ec689da264b3648c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a68c6f219c6ba63ec689da264b3648c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a2a68c6f219c6ba63ec689da264b3648c">set</a> (const T &amp;arg)</td></tr>
<tr class="memdesc:a2a68c6f219c6ba63ec689da264b3648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set given value as a result of the library function.  <a href="classLLU_1_1MArgumentManager.html#a2a68c6f219c6ba63ec689da264b3648c">More...</a><br /></td></tr>
<tr class="separator:a2a68c6f219c6ba63ec689da264b3648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52f3c0d3e66e4e9823abe6f7059bfda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLLU_1_1ProgressMonitor.html">ProgressMonitor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#af52f3c0d3e66e4e9823abe6f7059bfda">getProgressMonitor</a> (double step=<a class="el" href="classLLU_1_1ProgressMonitor.html#ade51268e3fb9ec8f83ce4847ff4e13a8">ProgressMonitor::getDefaultStep</a>()) const</td></tr>
<tr class="memdesc:af52f3c0d3e66e4e9823abe6f7059bfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <a class="el" href="classLLU_1_1ProgressMonitor.html" title="Stores and updates current progress of computation in a location shared between the library and WL Ke...">ProgressMonitor</a> shared with WL Kernel.  <a href="classLLU_1_1MArgumentManager.html#af52f3c0d3e66e4e9823abe6f7059bfda">More...</a><br /></td></tr>
<tr class="separator:af52f3c0d3e66e4e9823abe6f7059bfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa72d77dee424976d9332c1380594d9"><td class="memItemLeft" align="right" valign="top">numericarray_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a8aa72d77dee424976d9332c1380594d9">getNumericArrayType</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a8aa72d77dee424976d9332c1380594d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of MNumericArray at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#a8aa72d77dee424976d9332c1380594d9">More...</a><br /></td></tr>
<tr class="separator:a8aa72d77dee424976d9332c1380594d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8553574c9fdddfbc5361b5eb6078243"><td class="memTemplParams" colspan="2">template&lt;Passing Mode, class Operator , class... OpArgs&gt; </td></tr>
<tr class="memitem:ae8553574c9fdddfbc5361b5eb6078243"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#ae8553574c9fdddfbc5361b5eb6078243">operateOnNumericArray</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index, OpArgs &amp;&amp;... opArgs)</td></tr>
<tr class="memdesc:ae8553574c9fdddfbc5361b5eb6078243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform operation on <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> created from MNumericArray argument at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#ae8553574c9fdddfbc5361b5eb6078243">More...</a><br /></td></tr>
<tr class="separator:ae8553574c9fdddfbc5361b5eb6078243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30823065adfcdec20b54ecb02a90c4c2"><td class="memTemplParams" colspan="2">template&lt;Passing Mode = Passing::Automatic, class Operator &gt; </td></tr>
<tr class="memitem:a30823065adfcdec20b54ecb02a90c4c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a30823065adfcdec20b54ecb02a90c4c2">operateOnNumericArray</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index, Operator &amp;&amp;op)</td></tr>
<tr class="memdesc:a30823065adfcdec20b54ecb02a90c4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform operation on <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> created from MNumericArray argument at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#a30823065adfcdec20b54ecb02a90c4c2">More...</a><br /></td></tr>
<tr class="separator:a30823065adfcdec20b54ecb02a90c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2391b152a9a797e4f3f1c824721b1f32"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a2391b152a9a797e4f3f1c824721b1f32">getTensorType</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:a2391b152a9a797e4f3f1c824721b1f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of MTensor at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#a2391b152a9a797e4f3f1c824721b1f32">More...</a><br /></td></tr>
<tr class="separator:a2391b152a9a797e4f3f1c824721b1f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c059139aed11ef1d6d3aee71232cac"><td class="memTemplParams" colspan="2">template&lt;Passing Mode, class Operator , class... Args&gt; </td></tr>
<tr class="memitem:a99c059139aed11ef1d6d3aee71232cac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a99c059139aed11ef1d6d3aee71232cac">operateOnTensor</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index, Args &amp;&amp;... opArgs)</td></tr>
<tr class="memdesc:a99c059139aed11ef1d6d3aee71232cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform operation on <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> created from MTensor argument at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#a99c059139aed11ef1d6d3aee71232cac">More...</a><br /></td></tr>
<tr class="separator:a99c059139aed11ef1d6d3aee71232cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bd663435f36261f45aaa761d92dfb7"><td class="memTemplParams" colspan="2">template&lt;Passing Mode = Passing::Automatic, class Operator &gt; </td></tr>
<tr class="memitem:a12bd663435f36261f45aaa761d92dfb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a12bd663435f36261f45aaa761d92dfb7">operateOnTensor</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index, Operator &amp;&amp;op)</td></tr>
<tr class="memdesc:a12bd663435f36261f45aaa761d92dfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform operation on <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> created from MTensor argument at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#a12bd663435f36261f45aaa761d92dfb7">More...</a><br /></td></tr>
<tr class="separator:a12bd663435f36261f45aaa761d92dfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf777535ea8fea699b7f4bfb95793540"><td class="memItemLeft" align="right" valign="top">imagedata_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#adf777535ea8fea699b7f4bfb95793540">getImageType</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index) const</td></tr>
<tr class="memdesc:adf777535ea8fea699b7f4bfb95793540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of MImage at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#adf777535ea8fea699b7f4bfb95793540">More...</a><br /></td></tr>
<tr class="separator:adf777535ea8fea699b7f4bfb95793540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1953b7c33ec63d14e898e04aeb6e7"><td class="memTemplParams" colspan="2">template&lt;Passing Mode, class Operator , class... Args&gt; </td></tr>
<tr class="memitem:a9ec1953b7c33ec63d14e898e04aeb6e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a9ec1953b7c33ec63d14e898e04aeb6e7">operateOnImage</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index, Args &amp;&amp;... opArgs)</td></tr>
<tr class="memdesc:a9ec1953b7c33ec63d14e898e04aeb6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform operation on <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> created from MImage argument at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#a9ec1953b7c33ec63d14e898e04aeb6e7">More...</a><br /></td></tr>
<tr class="separator:a9ec1953b7c33ec63d14e898e04aeb6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7592405c5afbeca880f22ccc59d37921"><td class="memTemplParams" colspan="2">template&lt;Passing Mode = Passing::Automatic, class Operator &gt; </td></tr>
<tr class="memitem:a7592405c5afbeca880f22ccc59d37921"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html#a7592405c5afbeca880f22ccc59d37921">operateOnImage</a> (<a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a> index, Operator &amp;&amp;op)</td></tr>
<tr class="memdesc:a7592405c5afbeca880f22ccc59d37921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform operation on <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> created from MImage argument at position <code>index</code> in <code>Args</code>.  <a href="classLLU_1_1MArgumentManager.html#a7592405c5afbeca880f22ccc59d37921">More...</a><br /></td></tr>
<tr class="separator:a7592405c5afbeca880f22ccc59d37921"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Type aliases documentation</h2>
<a id="a501e118c237c8d86d944028b974451e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501e118c237c8d86d944028b974451e9">&#9670;&nbsp;</a></span>RequestedType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">LLU::MArgumentManager::RequestedType</a> =  typename RequestedTypeImpl&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RequestedType&lt;T&gt; is usually just T and is used as return type of MArgumentManager::get(size_type) </p>

</div>
</div>
<a id="a99eeec737c914999dc13bf945fd5b3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eeec737c914999dc13bf945fd5b3d5">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">LLU::MArgumentManager::size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type for indexing the list of arguments that <a class="el" href="classLLU_1_1MArgumentManager.html" title="Manages arguments exchanged between the paclet C++ code and LibraryLink interface.">MArgumentManager</a> manages. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0fb2b3e343ef1f6bc2734fc1d5c0f198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb2b3e343ef1f6bc2734fc1d5c0f198">&#9670;&nbsp;</a></span>MArgumentManager() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLU::MArgumentManager::MArgumentManager </td>
          <td>(</td>
          <td class="paramtype">mint&#160;</td>
          <td class="paramname"><em>Argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MArgument *&#160;</td>
          <td class="paramname"><em>Args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MArgument &amp;&#160;</td>
          <td class="paramname"><em>Res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Argc</td><td>- number of MArguments provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Args</td><td>- MArguments provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Res</td><td>- reference to output MArgument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a290a9939e31c44d370bf560ea3ada1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290a9939e31c44d370bf560ea3ada1a2">&#9670;&nbsp;</a></span>MArgumentManager() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLU::MArgumentManager::MArgumentManager </td>
          <td>(</td>
          <td class="paramtype">WolframLibraryData&#160;</td>
          <td class="paramname"><em>ld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mint&#160;</td>
          <td class="paramname"><em>Argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MArgument *&#160;</td>
          <td class="paramname"><em>Args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MArgument &amp;&#160;</td>
          <td class="paramname"><em>Res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ld</td><td>- library data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Argc</td><td>- number of MArguments provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Args</td><td>- MArguments provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Res</td><td>- reference to output MArgument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5a58218d6199891564ea692da4a225e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a58218d6199891564ea692da4a225e4">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">RequestedType</a>&lt;T&gt; LLU::MArgumentManager::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract library function argument at given index and convert it from MArgument to a desired type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- any type, for types not supported by default developers may specialize this function template </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position of desired argument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a value of type T created from the specified input argument </dd></dl>

</div>
</div>
<a id="ac05484aa8782e4b0e550366780433200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05484aa8782e4b0e550366780433200">&#9670;&nbsp;</a></span>getBoolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLU::MArgumentManager::getBoolean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type <b>mbool</b> at position <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MArgument of type <b>bool</b> at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8db1878ff9e9e35f6f63117d686e63b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db1878ff9e9e35f6f63117d686e63b9">&#9670;&nbsp;</a></span>getComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; LLU::MArgumentManager::getComplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type <b>mcomplex</b> at position <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MArgument value at position <code>index</code> converted to <b>std::complex&lt;double&gt;</b> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1f41521d97f42fc7797f698d5b227e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f41521d97f42fc7797f698d5b227e9">&#9670;&nbsp;</a></span>getCString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * LLU::MArgumentManager::getCString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value of MArgument of type <b>"UTF8String"</b> at position <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>C-string which was received from LibraryLink </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">LLErrorCode::MArgumentIndexError</td><td>- if <code>index</code> is out-of-bounds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classLLU_1_1MArgumentManager.html" title="Manages arguments exchanged between the paclet C++ code and LibraryLink interface.">MArgumentManager</a> is responsible for disowning string arguments. Do not call free() or delete() on resulting pointer. </dd></dl>

</div>
</div>
<a id="a44796732a9facd368d49ac9ae1298a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44796732a9facd368d49ac9ae1298a27">&#9670;&nbsp;</a></span>getDataList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Passing Mode = Passing::Automatic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLLU_1_1DataList.html">DataList</a>&lt;T&gt; LLU::MArgumentManager::getDataList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get DataStore with all nodes of the same type from MArgument at position <code>index</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of data stored in each node of DataStore, it T is MArgumentType::MArgument it will accept any node </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> wrapper of MArgument at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>DataList&lt;T&gt;::DataList(DataStore ds); </dd></dl>

</div>
</div>
<a id="a919afbc251bf7949250e58f36a6ac2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919afbc251bf7949250e58f36a6ac2db">&#9670;&nbsp;</a></span>getDataStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataStore LLU::MArgumentManager::getDataStore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type DataStore at position <code>index</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Use of this function is discouraged. Use getDataList instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DataStore of MArgument at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac68defdac36d7d6f3f109cd22b23f60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68defdac36d7d6f3f109cd22b23f60b">&#9670;&nbsp;</a></span>getGenericDataList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode = Passing::Automatic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLLU.html#a4a9e8e31bf555d15928845a173704aa9">GenericDataList</a> LLU::MArgumentManager::getGenericDataList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type DataStore at position <code>index</code> and wrap it into generic <a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper of DataStore with given passing mode </dd></dl>

</div>
</div>
<a id="a004b0cb543254f8ad1625e3c6fa9d4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004b0cb543254f8ad1625e3c6fa9d4a2">&#9670;&nbsp;</a></span>getGenericImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode = Passing::Automatic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLLU.html#a7013557ff73aaad19a9a5411520be837">GenericImage</a> LLU::MArgumentManager::getGenericImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MImage at position <code>index</code> and wrap it into generic <a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper of MImage with given passing mode </dd></dl>

</div>
</div>
<a id="a58a9b6e0b93f2f1fb3fdc1ad1cc28ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a9b6e0b93f2f1fb3fdc1ad1cc28ad6">&#9670;&nbsp;</a></span>getGenericNumericArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode = Passing::Automatic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLLU.html#ac246fc9334d25bf0df9d08f0bfb8927d">GenericNumericArray</a> LLU::MArgumentManager::getGenericNumericArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MNumericArray at position <code>index</code> and wrap it into generic <a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper of MNumericArray with given passing mode </dd></dl>

</div>
</div>
<a id="a42fb955aaa75872ec84a628b1961b009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fb955aaa75872ec84a628b1961b009">&#9670;&nbsp;</a></span>getGenericTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode = Passing::Automatic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLLU.html#aa463b81b42bbdd7c6fb53e32132e0a2f">GenericTensor</a> LLU::MArgumentManager::getGenericTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MTensor at position <code>index</code> and wrap it into generic <a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> wrapper of MTensor with given passing mode </dd></dl>

</div>
</div>
<a id="ab86f91cdfe25094a523b4c585f6b6265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86f91cdfe25094a523b4c585f6b6265">&#9670;&nbsp;</a></span>getImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Passing Mode = Passing::Automatic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLLU_1_1Image.html">Image</a>&lt;T&gt; LLU::MArgumentManager::getImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MImage at position <code>index</code> and wrap it into <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of data stored in <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> wrapper of MArgument at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Image&lt;T&gt;::Image(const MImage ra); </dd></dl>

</div>
</div>
<a id="adf777535ea8fea699b7f4bfb95793540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf777535ea8fea699b7f4bfb95793540">&#9670;&nbsp;</a></span>getImageType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">imagedata_t LLU::MArgumentManager::getImageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type of MImage at position <code>index</code> in <code>Args</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MImage type </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3bd7cfb82e338e2f7d0e04c1423cfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bd7cfb82e338e2f7d0e04c1423cfb9">&#9670;&nbsp;</a></span>getInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T LLU::MArgumentManager::getInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type <b>mint</b> at position <code>index</code> with extra static_cast if needed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- integral type to convert <b>mint</b> to </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MArgument value at position <code>index</code> converted to <b>T</b> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c0e0d89b51e3ecebb05af6c96418893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0e0d89b51e3ecebb05af6c96418893">&#9670;&nbsp;</a></span>getManagedExpression()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ManagedExpr , class DynamicType  = ManagedExpr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DynamicType&amp; LLU::MArgumentManager::getManagedExpression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLLU_1_1ManagedExpressionStore.html">ManagedExpressionStore</a>&lt; ManagedExpr &gt; &amp;&#160;</td>
          <td class="paramname"><em>store</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to an instance of <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression that was sent from Wolfram Language as argument to a library function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ManagedExpr</td><td>- registered <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression class </td></tr>
    <tr><td class="paramname">DynamicType</td><td>- actual type of <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression, this must be ManagedExpr or its subclass </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position of desired argument in <code>Args</code> </td></tr>
    <tr><td class="paramname">store</td><td>- <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression store that manages expressions of type ManagedExpr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression </dd></dl>

</div>
</div>
<a id="af2b8c02c826fa0ee95ed8a9937ec6345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b8c02c826fa0ee95ed8a9937ec6345">&#9670;&nbsp;</a></span>getManagedExpressionPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ManagedExpr , class DynamicType  = ManagedExpr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;DynamicType&gt; LLU::MArgumentManager::getManagedExpressionPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLLU_1_1ManagedExpressionStore.html">ManagedExpressionStore</a>&lt; ManagedExpr &gt; &amp;&#160;</td>
          <td class="paramname"><em>store</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a shared pointer to an instance of <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression that was sent from Wolfram Language as argument to a library function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ManagedExpr</td><td>- registered <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression class </td></tr>
    <tr><td class="paramname">DynamicType</td><td>- actual type of <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression, this must be ManagedExpr or its subclass </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- position of desired argument in <code>Args</code> </td></tr>
    <tr><td class="paramname">store</td><td>- <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression store that manages expressions of type ManagedExpr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the <a class="el" href="structLLU_1_1MArgumentManager_1_1Managed.html" title="Helper struct to &quot;attach&quot; a passing mode to container type when passing it as template argument to MA...">Managed</a> Expression </dd></dl>

</div>
</div>
<a id="ac13a505910535cdc17f33f5632c4421a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13a505910535cdc17f33f5632c4421a">&#9670;&nbsp;</a></span>getMImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MImage LLU::MArgumentManager::getMImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MImage at position <code>index</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Use of this function is discouraged. Use getImage instead, if possible. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MImage of MArgument at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abec27fba3c06c10754485ee987786e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec27fba3c06c10754485ee987786e3d">&#9670;&nbsp;</a></span>getMNumericArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MNumericArray LLU::MArgumentManager::getMNumericArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MNumericArray at position <code>index</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Use of this function is discouraged. Use getNumericArray instead, if possible. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MArgument at position <code>index</code> interpreted as MNumericArray </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a827f6f1a8c5b7b75ce1df7f8959182ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827f6f1a8c5b7b75ce1df7f8959182ab">&#9670;&nbsp;</a></span>getMTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MTensor LLU::MArgumentManager::getMTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MTensor at position <code>index</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Use of this function is discouraged. Use getTensor instead, if possible. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTensor of MArgument at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9208b7904e478bd88b2518713a74a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9208b7904e478bd88b2518713a74a7b">&#9670;&nbsp;</a></span>getNumericArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Passing Mode = Passing::Automatic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLLU_1_1NumericArray.html">NumericArray</a>&lt;T&gt; LLU::MArgumentManager::getNumericArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MNumericArray at position <code>index</code> and wrap it into <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of data stored in <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> wrapper of MArgument at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>NumericArray&lt;T&gt;::NumericArray(const MNumericArray); </dd></dl>

</div>
</div>
<a id="a8aa72d77dee424976d9332c1380594d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa72d77dee424976d9332c1380594d9">&#9670;&nbsp;</a></span>getNumericArrayType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numericarray_data_t LLU::MArgumentManager::getNumericArrayType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type of MNumericArray at position <code>index</code> in <code>Args</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MNumericArray type </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af52f3c0d3e66e4e9823abe6f7059bfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52f3c0d3e66e4e9823abe6f7059bfda">&#9670;&nbsp;</a></span>getProgressMonitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLLU_1_1ProgressMonitor.html">ProgressMonitor</a> LLU::MArgumentManager::getProgressMonitor </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em> = <code><a class="el" href="classLLU_1_1ProgressMonitor.html#ade51268e3fb9ec8f83ce4847ff4e13a8">ProgressMonitor::getDefaultStep</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <a class="el" href="classLLU_1_1ProgressMonitor.html" title="Stores and updates current progress of computation in a location shared between the library and WL Ke...">ProgressMonitor</a> shared with WL Kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>- step value for progress monitor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instance of <a class="el" href="classLLU_1_1ProgressMonitor.html" title="Stores and updates current progress of computation in a location shared between the library and WL Ke...">ProgressMonitor</a> class. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you haven't specified "ProgressMonitor" option when loading the library function with PacletFunctionSet, then the behavior of <code>getProgressMonitor</code> is undefined. </dd></dl>

</div>
</div>
<a id="ac72bb31d4f4b681edc66224495105ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72bb31d4f4b681edc66224495105ee8">&#9670;&nbsp;</a></span>getReal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LLU::MArgumentManager::getReal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type <b>mreal</b> at position <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MArgument of type <b>double</b> at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae75704183d6d6f3143652c6f6e55c00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75704183d6d6f3143652c6f6e55c00e">&#9670;&nbsp;</a></span>getString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LLU::MArgumentManager::getString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value of MArgument of type <b>"UTF8String"</b> at position <code>index</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>std::string</b> which is created from MArgument at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">LLErrorCode::MArgumentIndexError</td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a5170d482d1adb7d5204b74f4647af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5170d482d1adb7d5204b74f4647af2">&#9670;&nbsp;</a></span>getTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Passing Mode = Passing::Automatic&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLLU_1_1Tensor.html">Tensor</a>&lt;T&gt; LLU::MArgumentManager::getTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get MArgument of type MTensor at position <code>index</code> and wrap it into <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of data stored in <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> wrapper of MArgument at position <code>index</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Tensor&lt;T&gt;::Tensor(const MTensor); </dd></dl>

</div>
</div>
<a id="a2391b152a9a797e4f3f1c824721b1f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2391b152a9a797e4f3f1c824721b1f32">&#9670;&nbsp;</a></span>getTensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char LLU::MArgumentManager::getTensorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type of MTensor at position <code>index</code> in <code>Args</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of desired MArgument in <code>Args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTensor type </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5416b32de02b012ad4ada580badf2791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5416b32de02b012ad4ada580badf2791">&#9670;&nbsp;</a></span>getTuple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">RequestedType</a>&lt;ArgTypes&gt;...&gt; LLU::MArgumentManager::getTuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract arguments from the Manager and return them as values of given types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArgTypes</td><td>- types that determine how each extracted argument will be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of function arguments </dd></dl>

</div>
</div>
<a id="a5149865c418e41356221edbcdeac9e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5149865c418e41356221edbcdeac9e7d">&#9670;&nbsp;</a></span>getTuple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ArgTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classLLU_1_1MArgumentManager.html#a501e118c237c8d86d944028b974451e9">RequestedType</a>&lt;ArgTypes&gt;...&gt; LLU::MArgumentManager::getTuple </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; <a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>, sizeof...(ArgTypes)&gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract arguments from the Manager at given positions and return them as values of given types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArgTypes</td><td>- types that determine how each extracted argument will be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>- position of desired arguments, need not be sorted, may contain repeated values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple of function arguments </dd></dl>

</div>
</div>
<a id="a9ec1953b7c33ec63d14e898e04aeb6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec1953b7c33ec63d14e898e04aeb6e7">&#9670;&nbsp;</a></span>operateOnImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode, class Operator , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::operateOnImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>opArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform operation on <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> created from MImage argument at position <code>index</code> in <code>Args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode of the <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> that will be processed </td></tr>
    <tr><td class="paramname">Operator</td><td>- any callable class </td></tr>
    <tr><td class="paramname">OpArgs...</td><td>- types of arguments of <code>operator()</code> in class <code>Operator</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of MImage in <code>Args</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opArgs</td><td>- arguments of Operator::operator() </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a5ecf45df8c18bcac56635e347158500c" title="error involving Image argument">ErrorName::MArgumentImageError</a></td><td>- if MImage argument has incorrect type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Operator::operator() has to be a template that takes a const Image&lt;T&gt;&amp; as first argument </dd></dl>

</div>
</div>
<a id="a7592405c5afbeca880f22ccc59d37921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7592405c5afbeca880f22ccc59d37921">&#9670;&nbsp;</a></span>operateOnImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode = Passing::Automatic, class Operator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::operateOnImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operator &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform operation on <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> created from MImage argument at position <code>index</code> in <code>Args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode of the <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> that will be processed </td></tr>
    <tr><td class="paramname">Operator</td><td>- any callable class </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of MImage in <code>Args</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>- callable object (possibly lambda) that takes only one argument - an <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a5ecf45df8c18bcac56635e347158500c" title="error involving Image argument">ErrorName::MArgumentImageError</a></td><td>- if MImage argument has incorrect type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8553574c9fdddfbc5361b5eb6078243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8553574c9fdddfbc5361b5eb6078243">&#9670;&nbsp;</a></span>operateOnNumericArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode, class Operator , class... OpArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::operateOnNumericArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OpArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>opArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform operation on <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> created from MNumericArray argument at position <code>index</code> in <code>Args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode of the <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> that will be processed </td></tr>
    <tr><td class="paramname">Operator</td><td>- any callable class </td></tr>
    <tr><td class="paramname">OpArgs...</td><td>- types of arguments of <code>operator()</code> in class <code>Operator</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of MNumericArray in <code>Args</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opArgs</td><td>- arguments of Operator::operator() </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Operator::operator() has to be a template that takes a const NumericArray&lt;T&gt;&amp; as first argument </dd></dl>

</div>
</div>
<a id="a30823065adfcdec20b54ecb02a90c4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30823065adfcdec20b54ecb02a90c4c2">&#9670;&nbsp;</a></span>operateOnNumericArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode = Passing::Automatic, class Operator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::operateOnNumericArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operator &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform operation on <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> created from MNumericArray argument at position <code>index</code> in <code>Args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode of the <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> that will be processed </td></tr>
    <tr><td class="paramname">Operator</td><td>- any callable class </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of MNumericArray in <code>Args</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>- callable object (possibly lambda) that takes only one argument - a <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99c059139aed11ef1d6d3aee71232cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c059139aed11ef1d6d3aee71232cac">&#9670;&nbsp;</a></span>operateOnTensor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode, class Operator , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::operateOnTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>opArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform operation on <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> created from MTensor argument at position <code>index</code> in <code>Args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode of the <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> that will be processed </td></tr>
    <tr><td class="paramname">Operator</td><td>- any callable class </td></tr>
    <tr><td class="paramname">OpArgs...</td><td>- types of arguments of <code>operator()</code> in class <code>Operator</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of MTensor in <code>Args</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opArgs</td><td>- arguments of Operator::operator() </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a50a4093b4fb77f9a282992157f088298" title="error involving Tensor argument">ErrorName::MArgumentTensorError</a></td><td>- if MTensor argument has incorrect type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Operator::operator() has to be a template that takes a const Tensor&lt;T&gt;&amp; as first argument </dd></dl>

</div>
</div>
<a id="a12bd663435f36261f45aaa761d92dfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bd663435f36261f45aaa761d92dfb7">&#9670;&nbsp;</a></span>operateOnTensor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Passing Mode = Passing::Automatic, class Operator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::operateOnTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLLU_1_1MArgumentManager.html#a99eeec737c914999dc13bf945fd5b3d5">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operator &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform operation on <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> created from MTensor argument at position <code>index</code> in <code>Args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mode</td><td>- passing mode of the <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> that will be processed </td></tr>
    <tr><td class="paramname">Operator</td><td>- any callable class </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>- position of MTensor in <code>Args</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>- callable object (possibly lambda) that takes only one argument - a <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a719ac23d93517e26a06370af5acd34b3" title="wrong argument index">ErrorName::MArgumentIndexError</a></td><td>- if <code>index</code> is out-of-bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a50a4093b4fb77f9a282992157f088298" title="error involving Tensor argument">ErrorName::MArgumentTensorError</a></td><td>- if MTensor argument has incorrect type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace962bd6a20d9879b1a35b4c1a276970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace962bd6a20d9879b1a35b4c1a276970">&#9670;&nbsp;</a></span>set() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>result</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>- boolean value to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94a1e1cbc652ba634aef208cd86dfda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a1e1cbc652ba634aef208cd86dfda2">&#9670;&nbsp;</a></span>set() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>str</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>- reference to <b>std::string</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5734eef8e00e88097ec62d04afca3b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5734eef8e00e88097ec62d04afca3b72">&#9670;&nbsp;</a></span>set() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1DataList.html">DataList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set DataStore wrapped in <a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> <code>ds</code> as output MArgument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of data stored in each node of DataStore </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>- const reference to <a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> which should pass its internal DataStore to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c1e87824053e944c082d65220f1a4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1e87824053e944c082d65220f1a4fb">&#9670;&nbsp;</a></span>set() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceLLU.html#a4a9e8e31bf555d15928845a173704aa9">GenericDataList</a> &amp;&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set DataStore wrapped by <code>ds</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>- reference to generic DataStore which should pass its internal DataStore to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e4c43ca5b936af4ec25beb6833187dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4c43ca5b936af4ec25beb6833187dd">&#9670;&nbsp;</a></span>set() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceLLU.html#a7013557ff73aaad19a9a5411520be837">GenericImage</a> &amp;&#160;</td>
          <td class="paramname"><em>im</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set MImage wrapped by <code>im</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">im</td><td>- reference to generic <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> which should pass its internal MImage to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a793a666bd5ab710f43d71b278dcfcd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793a666bd5ab710f43d71b278dcfcd18">&#9670;&nbsp;</a></span>set() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceLLU.html#ac246fc9334d25bf0df9d08f0bfb8927d">GenericNumericArray</a> &amp;&#160;</td>
          <td class="paramname"><em>na</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set MNumericArray wrapped by <code>na</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">na</td><td>- reference to generic <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> which should pass its internal MNumericArray to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7c44095e8d5ddce1cf723c6b7440e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c44095e8d5ddce1cf723c6b7440e20">&#9670;&nbsp;</a></span>set() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceLLU.html#aa463b81b42bbdd7c6fb53e32132e0a2f">GenericTensor</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set MTensor wrapped by <code>t</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>- reference to generic <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> which should pass its internal MTensor to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46f76f2b5f063a04c59785b74eaac249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f76f2b5f063a04c59785b74eaac249">&#9670;&nbsp;</a></span>set() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>im</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set MImage wrapped by <code>im</code> as output MArgument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">im</td><td>- reference to <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> which should pass its internal MImage to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bc82b183bd2e3b2a05cb55da61ed7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc82b183bd2e3b2a05cb55da61ed7da">&#9670;&nbsp;</a></span>set() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1NumericArray.html">NumericArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>na</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set MNumericArray wrapped by <code>na</code> as output MArgument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">na</td><td>- reference to <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> which should pass its internal MNumericArray to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31dcb45ec505ca4d4b99b8b44e4bebe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31dcb45ec505ca4d4b99b8b44e4bebe7">&#9670;&nbsp;</a></span>set() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>str</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>- reference to <b>std::string</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a68c6f219c6ba63ec689da264b3648c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a68c6f219c6ba63ec689da264b3648c">&#9670;&nbsp;</a></span>set() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set given value as a result of the library function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- any type, for types not supported by default developers are encouraged to specialize this function template </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f8469a36c03ec66b0f0324da25ca141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8469a36c03ec66b0f0324da25ca141">&#9670;&nbsp;</a></span>set() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1Tensor.html">Tensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ten</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set MTensor wrapped by <code>ten</code> as output MArgument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ten</td><td>- reference to <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> which should pass its internal MTensor to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2048dfd36c3ae75a06cd55fe23b54fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2048dfd36c3ae75a06cd55fe23b54fb8">&#9670;&nbsp;</a></span>set() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>result</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>- value of type <b>double</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af36018287bd3701493f70ebd4b1378f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36018287bd3701493f70ebd4b1378f9">&#9670;&nbsp;</a></span>set() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">mint&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>result</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>- value of type <b>mint</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code>result</code> will be implicitly casted to <b>mint</b> with no overflow check </dd></dl>

</div>
</div>
<a id="a7bc9e93fd301924266866b25bd18b130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc9e93fd301924266866b25bd18b130">&#9670;&nbsp;</a></span>set() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; double &gt;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>c</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- value of type <b>std::complex&lt;double&gt;</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac84c4cfea5a3a0fb50f9958d8d0d8c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84c4cfea5a3a0fb50f9958d8d0d8c62">&#9670;&nbsp;</a></span>set() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::set </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>str</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>- reference to <b>std::string</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6df0fce424f60f9bd8348aad29b3593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6df0fce424f60f9bd8348aad29b3593">&#9670;&nbsp;</a></span>setBoolean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setBoolean </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>result</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>- boolean value to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03025301159406fcc28fbf75012d6459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03025301159406fcc28fbf75012d6459">&#9670;&nbsp;</a></span>setComplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setComplex </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; double &gt;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>c</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- value of type <b>std::complex&lt;double&gt;</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c18a2b2af22583744f01bfcf6a3e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c18a2b2af22583744f01bfcf6a3e46">&#9670;&nbsp;</a></span>setDataList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setDataList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1DataList.html">DataList</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set DataStore wrapped in <a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> <code>ds</code> as output MArgument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of data stored in each node of DataStore </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>- const reference to <a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> which should pass its internal DataStore to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90aa5c17a67b7f604952f3467829305a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aa5c17a67b7f604952f3467829305a">&#9670;&nbsp;</a></span>setDataStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setDataStore </td>
          <td>(</td>
          <td class="paramtype">DataStore&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set DataStore as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>- DataStore to be passed to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14abe54f5e863363775637cb9818c14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14abe54f5e863363775637cb9818c14a">&#9670;&nbsp;</a></span>setImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1Image.html">Image</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>im</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MImage wrapped by <code>im</code> as output MArgument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">im</td><td>- reference to <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> which should pass its internal MImage to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef09c1ee1bb3336f088157ea2267b532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef09c1ee1bb3336f088157ea2267b532">&#9670;&nbsp;</a></span>setInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setInteger </td>
          <td>(</td>
          <td class="paramtype">mint&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>result</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>- value of type <b>mint</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><code>result</code> will be implicitly casted to <b>mint</b> with no overflow check </dd></dl>

</div>
</div>
<a id="ad48f2a3f8e4f852ac9e13af51e17fd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48f2a3f8e4f852ac9e13af51e17fd74">&#9670;&nbsp;</a></span>setMImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setMImage </td>
          <td>(</td>
          <td class="paramtype">MImage&#160;</td>
          <td class="paramname"><em>im</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MImage as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">im</td><td>- MImage to be passed to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcd058a68f5ce18867c1d70450a45e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd058a68f5ce18867c1d70450a45e12">&#9670;&nbsp;</a></span>setMintAndCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LLU::MArgumentManager::setMintAndCheck </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>result</code> as output MArgument and check for overflow. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- integral type to be casted to <b>mint</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>- value to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff overflow occurred and the value had to be clipped </dd></dl>

</div>
</div>
<a id="a206866cdaa619f4a25b5acd628797dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206866cdaa619f4a25b5acd628797dcb">&#9670;&nbsp;</a></span>setMNumericArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setMNumericArray </td>
          <td>(</td>
          <td class="paramtype">MNumericArray&#160;</td>
          <td class="paramname"><em>na</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MNumericArray as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">na</td><td>- MNumericArray to be passed to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af85b070a81792c9b7d776930262606a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85b070a81792c9b7d776930262606a7">&#9670;&nbsp;</a></span>setMTensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setMTensor </td>
          <td>(</td>
          <td class="paramtype">MTensor&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MTensor as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>- MTensor to be passed to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a205ad433b345687c1ed15aba4782a9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205ad433b345687c1ed15aba4782a9e5">&#9670;&nbsp;</a></span>setNumericArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setNumericArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1NumericArray.html">NumericArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>na</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MNumericArray wrapped by <code>na</code> as output MArgument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">na</td><td>- reference to <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> which should pass its internal MNumericArray to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a039b2c94af57cbb77f71ddf1b5e5b35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039b2c94af57cbb77f71ddf1b5e5b35a">&#9670;&nbsp;</a></span>setReal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setReal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <code>result</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result</td><td>- value of type <b>double</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a335c472c1f964b634ac36948efb74b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335c472c1f964b634ac36948efb74b4b">&#9670;&nbsp;</a></span>setSparseArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setSparseArray </td>
          <td>(</td>
          <td class="paramtype">MSparseArray&#160;</td>
          <td class="paramname"><em>sa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MSparseArray as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sa</td><td>- MSparseArray to be passed to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc510cab97269d495321d09ebad7126e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc510cab97269d495321d09ebad7126e">&#9670;&nbsp;</a></span>setString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a79a2d2be982f1e9f89579d95a1d3918a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a2d2be982f1e9f89579d95a1d3918a">&#9670;&nbsp;</a></span>setString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <code>str</code> as output MArgument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>- reference to <b>std::string</b> to be returned to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a976fe7c259133c788bdd8916d2f78e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976fe7c259133c788bdd8916d2f78e7e">&#9670;&nbsp;</a></span>setString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab0a55b48a13fdaa532b50cff7bf294b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a55b48a13fdaa532b50cff7bf294b3">&#9670;&nbsp;</a></span>setTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::MArgumentManager::setTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1Tensor.html">Tensor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ten</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MTensor wrapped by <code>ten</code> as output MArgument. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ten</td><td>- reference to <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> which should pass its internal MTensor to LibraryLink </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceLLU.html">LLU</a></li><li class="navelem"><a class="el" href="classLLU_1_1MArgumentManager.html">MArgumentManager</a></li>
    <li class="footer">Generated on Tue Oct 6 2020 12:46:59 for LibraryLink Utilities by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
