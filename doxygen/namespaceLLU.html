<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LibraryLink Utilities: LLU Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:600" rel="stylesheet">
<script src="striped_bg.js"></script>
<link href="style.css" rel="stylesheet" type="text/css"/>
<link href="style.css.map" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="LLULogo_144.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LibraryLink Utilities
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Modern C++ wrapper over LibraryLink and WSTP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceLLU.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Type aliases</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LLU Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace of LibraryLink Utilities.  
<a href="namespaceLLU.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace of LibraryLink Utilities. </p>
<p>Every symbol defined in <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> will be in this namespace, but one needs to remember that <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> internally includes WolframLibrary and WSTP headers which define C APIs and therefore do not use namespaces and in consequence will inject names in the global namespace. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceLLU_1_1Argument"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU_1_1Argument.html">Argument</a></td></tr>
<tr class="memdesc:namespaceLLU_1_1Argument"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for functionality related to arguments passed from LibraryLink to library functions and their types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLLU_1_1ErrorCode"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU_1_1ErrorCode.html">ErrorCode</a></td></tr>
<tr class="memdesc:namespaceLLU_1_1ErrorCode"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes predefined in Library Link. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLLU_1_1ErrorName"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU_1_1ErrorName.html">ErrorName</a></td></tr>
<tr class="memdesc:namespaceLLU_1_1ErrorName"><td class="mdescLeft">&#160;</td><td class="mdescRight">Names of all errors used across <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLLU_1_1NA"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU_1_1NA.html">NA</a></td></tr>
<tr class="memdesc:namespaceLLU_1_1NA"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small namespace for <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> related utilities. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceLLU_1_1WS"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU_1_1WS.html">WS</a></td></tr>
<tr class="memdesc:namespaceLLU_1_1WS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains definitions related to WSTP functionality in <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1AlwaysReadExclusiveWrite.html">AlwaysReadExclusiveWrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default policy for Import/Export paclets - always allow reading, deny writing when we write.  <a href="structLLU_1_1AlwaysReadExclusiveWrite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1DataList.html">DataList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top-level wrapper over LibraryLink's DataStore.  <a href="classLLU_1_1DataList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1DataNode.html">DataNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper over DataStoreNode structure from LibraryLink.  <a href="classLLU_1_1DataNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1DataStoreIterator.html">DataStoreIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy input iterator over DataStoreNodes, when dereferenced yields <a class="el" href="structLLU_1_1GenericDataNode.html" title="Basic wrapper over DataStoreNode, provides class-like interface and conversion of the underlying valu...">GenericDataNode</a> proxy objects.  <a href="classLLU_1_1DataStoreIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1dependent__false.html">dependent_false</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a type that inherits from false_type and ignores the template parameter completely.  <a href="structLLU_1_1dependent__false.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1ErrorManager.html">ErrorManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Static" class responsible for error registration and throwing  <a href="classLLU_1_1ErrorManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1GenericDataNode.html">GenericDataNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic wrapper over DataStoreNode, provides class-like interface and conversion of the underlying value from MArgument to TypedArgument.  <a href="structLLU_1_1GenericDataNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1Image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a class template, where template parameter T is the type of data elements. <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a> is derived from <a class="el" href="classLLU_1_1MArray.html" title="This is a class template, where template parameter T is the type of data elements....">MArray</a>.  <a href="classLLU_1_1Image.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1ImageInterface.html">ImageInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines a basic set of operations on an image.  <a href="structLLU_1_1ImageInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1ImageView.html">ImageView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, light-weight, non-owning wrappper over MImage.  <a href="classLLU_1_1ImageView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1IterableContainer.html">IterableContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that provides iterators (c/r/begin and c/r/end methods) and subscript operator for any contiguous container.  <a href="classLLU_1_1IterableContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1LibraryData.html">LibraryData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure offers a static copy of WolframLibData accessible throughout the whole life of the DLL.  <a href="structLLU_1_1LibraryData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1LibraryLinkError.html">LibraryLinkError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing an exception in paclet code.  <a href="classLLU_1_1LibraryLinkError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1Logger.html" title="Logger class is responsible for sending log messages via WSTP to Mathematica.">Logger</a> class is responsible for sending log messages via WSTP to Mathematica.  <a href="classLLU_1_1Logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1ManagedExpressionStore.html">ManagedExpressionStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1ManagedExpressionStore.html" title="ManagedExpressionStore will keep track of instances of managed class T and will provide safe access t...">ManagedExpressionStore</a> will keep track of instances of managed class T and will provide safe access to them.  <a href="classLLU_1_1ManagedExpressionStore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArgumentManager.html">MArgumentManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages arguments exchanged between the paclet C++ code and LibraryLink interface.  <a href="classLLU_1_1MArgumentManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArray.html">MArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a class template, where template parameter T is the type of data elements. <a class="el" href="classLLU_1_1MArray.html" title="This is a class template, where template parameter T is the type of data elements....">MArray</a> is the base class for <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a>, <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> and <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a>.  <a href="classLLU_1_1MArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MArrayDimensions.html">MArrayDimensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that carries meta-information about container's size and dimensions.  <a href="classLLU_1_1MArrayDimensions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MContainer.html">MContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> is an abstract class template for generic containers.&#160;Only specializations shall be used.  <a href="classLLU_1_1MContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4.html">MContainer&lt; MArgumentType::DataStore &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for DataStore, provides basic list interface for the underlying raw DataStore.  <a href="classLLU_1_1MContainer_3_01MArgumentType_1_1DataStore_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4.html">MContainer&lt; MArgumentType::Image &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MImage.  <a href="classLLU_1_1MContainer_3_01MArgumentType_1_1Image_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4.html">MContainer&lt; MArgumentType::NumericArray &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MNumericArray.  <a href="classLLU_1_1MContainer_3_01MArgumentType_1_1NumericArray_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4.html">MContainer&lt; MArgumentType::Tensor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MTensor.  <a href="classLLU_1_1MContainer_3_01MArgumentType_1_1Tensor_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1MContainerBase.html">MContainerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template of the base class for all generic containers.  <a href="classLLU_1_1MContainerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1NameAdaptor.html">NameAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator adaptor for <a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> that makes begin() and end() return proxy iterators for node names.  <a href="structLLU_1_1NameAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1NodeIterator.html">NodeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple proxy input iterator that goes over a DataStore and returns proxy DataNodes when dereferenced.  <a href="structLLU_1_1NodeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1NodeNameIterator.html">NodeNameIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple proxy input iterator that goes over a DataStore and returns node names when dereferenced.  <a href="structLLU_1_1NodeNameIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1NodeValueIterator.html">NodeValueIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple proxy input iterator that goes over a DataStore and returns node values of requested type when dereferenced.  <a href="structLLU_1_1NodeValueIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1NumericArray.html">NumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a class template, where template parameter T is the type of data elements. <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> is derived from <a class="el" href="classLLU_1_1MArray.html" title="This is a class template, where template parameter T is the type of data elements....">MArray</a>.  <a href="classLLU_1_1NumericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1NumericArrayFromEnum.html">NumericArrayFromEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility structure that matches an MNumericArray data type with corresponding C++ type.  <a href="structLLU_1_1NumericArrayFromEnum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1NumericArrayInterface.html">NumericArrayInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines a basic set of operations on a numeric array.  <a href="structLLU_1_1NumericArrayInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1NumericArrayTypedView.html">NumericArrayTypedView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, light-weight, non-owning wrappper over MNumericArray.  <a href="classLLU_1_1NumericArrayTypedView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1NumericArrayView.html">NumericArrayView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, light-weight, non-owning, data-type-agnostic wrappper over MNumericArray.  <a href="classLLU_1_1NumericArrayView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1PrimitiveWrapper.html">PrimitiveWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small class that wraps a reference to MArgument and provides proper API to work with this MArgument.  <a href="classLLU_1_1PrimitiveWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1ProgressMonitor.html">ProgressMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores and updates current progress of computation in a location shared between the library and WL Kernel.  <a href="classLLU_1_1ProgressMonitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1SharePolicy.html">SharePolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for shared access policies on Windows.  <a href="structLLU_1_1SharePolicy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a class template, where template parameter T is the type of data elements. <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> is derived from <a class="el" href="classLLU_1_1MArray.html" title="This is a class template, where template parameter T is the type of data elements....">MArray</a>.  <a href="classLLU_1_1Tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1TensorInterface.html">TensorInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines a basic set of operations on a tensor.  <a href="structLLU_1_1TensorInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1TensorView.html">TensorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, light-weight, non-owning wrappper over MTensor.  <a href="classLLU_1_1TensorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1TypedImage.html">TypedImage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed interface for <a class="el" href="classLLU_1_1Image.html" title="This is a class template, where template parameter T is the type of data elements....">Image</a>.  <a href="classLLU_1_1TypedImage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1TypedNumericArray.html">TypedNumericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed interface for <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a>.  <a href="classLLU_1_1TypedNumericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1TypedTensor.html">TypedTensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed interface for <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a>.  <a href="classLLU_1_1TypedTensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLLU_1_1ValueAdaptor.html">ValueAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator adaptor for <a class="el" href="classLLU_1_1DataList.html" title="Top-level wrapper over LibraryLink&#39;s DataStore.">DataList</a> that makes begin() and end() return proxy iterators for node values.  <a href="structLLU_1_1ValueAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLLU_1_1WSStream.html">WSStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class over WSTP with a stream-like interface.  <a href="classLLU_1_1WSStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Type aliases</h2></td></tr>
<tr class="memitem:ae9b523e0cd42c388792d850579518319"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#ae9b523e0cd42c388792d850579518319">BasicPool</a> = <a class="el" href="classLLU_1_1Async_1_1BasicThreadPool.html">Async::BasicThreadPool</a>&lt; <a class="el" href="classLLU_1_1Async_1_1ThreadsafeQueue.html">Async::ThreadsafeQueue</a>&lt; <a class="el" href="classLLU_1_1Async_1_1FunctionWrapper.html">Async::FunctionWrapper</a> &gt; &gt;</td></tr>
<tr class="memdesc:ae9b523e0cd42c388792d850579518319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for BasicThreadPool with ThreadsafeQueue storing Async::FunctionWrappers.  <a href="namespaceLLU.html#ae9b523e0cd42c388792d850579518319">More...</a><br /></td></tr>
<tr class="separator:ae9b523e0cd42c388792d850579518319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970fbec367bc4714ac2b9d210d649f55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a970fbec367bc4714ac2b9d210d649f55">ThreadPool</a> = <a class="el" href="classLLU_1_1Async_1_1GenericThreadPool.html">Async::GenericThreadPool</a>&lt; <a class="el" href="classLLU_1_1Async_1_1ThreadsafeQueue.html">Async::ThreadsafeQueue</a>&lt; <a class="el" href="classLLU_1_1Async_1_1FunctionWrapper.html">Async::FunctionWrapper</a> &gt;, <a class="el" href="classLLU_1_1Async_1_1WorkStealingQueue.html">Async::WorkStealingQueue</a>&lt; std::deque&lt; <a class="el" href="classLLU_1_1Async_1_1FunctionWrapper.html">Async::FunctionWrapper</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a970fbec367bc4714ac2b9d210d649f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for GenericThreadPool with ThreadsafeQueue and WorkStealingQueue storing Async::FunctionWrappers.  <a href="namespaceLLU.html#a970fbec367bc4714ac2b9d210d649f55">More...</a><br /></td></tr>
<tr class="separator:a970fbec367bc4714ac2b9d210d649f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9e8e31bf555d15928845a173704aa9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a4a9e8e31bf555d15928845a173704aa9">GenericDataList</a> = <a class="el" href="classLLU_1_1MContainer.html">MContainer</a>&lt; MArgumentType::DataStore &gt;</td></tr>
<tr class="memdesc:a4a9e8e31bf555d15928845a173704aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for DataStore is called GenericDataList.  <a href="namespaceLLU.html#a4a9e8e31bf555d15928845a173704aa9">More...</a><br /></td></tr>
<tr class="separator:a4a9e8e31bf555d15928845a173704aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7013557ff73aaad19a9a5411520be837"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a7013557ff73aaad19a9a5411520be837">GenericImage</a> = <a class="el" href="classLLU_1_1MContainer.html">MContainer</a>&lt; MArgumentType::Image &gt;</td></tr>
<tr class="memdesc:a7013557ff73aaad19a9a5411520be837"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MImage is called GenericImage.  <a href="namespaceLLU.html#a7013557ff73aaad19a9a5411520be837">More...</a><br /></td></tr>
<tr class="separator:a7013557ff73aaad19a9a5411520be837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac246fc9334d25bf0df9d08f0bfb8927d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#ac246fc9334d25bf0df9d08f0bfb8927d">GenericNumericArray</a> = <a class="el" href="classLLU_1_1MContainer.html">MContainer</a>&lt; MArgumentType::NumericArray &gt;</td></tr>
<tr class="memdesc:ac246fc9334d25bf0df9d08f0bfb8927d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MNumericArray is called GenericNumericArray.  <a href="namespaceLLU.html#ac246fc9334d25bf0df9d08f0bfb8927d">More...</a><br /></td></tr>
<tr class="separator:ac246fc9334d25bf0df9d08f0bfb8927d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa463b81b42bbdd7c6fb53e32132e0a2f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#aa463b81b42bbdd7c6fb53e32132e0a2f">GenericTensor</a> = <a class="el" href="classLLU_1_1MContainer.html">MContainer</a>&lt; MArgumentType::Tensor &gt;</td></tr>
<tr class="memdesc:aa463b81b42bbdd7c6fb53e32132e0a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MTensor is called GenericTensor.  <a href="namespaceLLU.html#aa463b81b42bbdd7c6fb53e32132e0a2f">More...</a><br /></td></tr>
<tr class="separator:aa463b81b42bbdd7c6fb53e32132e0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b7b156baa9302492eb6a7b7cedf49a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a69b7b156baa9302492eb6a7b7cedf49a">FilePtr</a> = std::unique_ptr&lt; std::FILE, int(*)(std::FILE *)&gt;</td></tr>
<tr class="memdesc:a69b7b156baa9302492eb6a7b7cedf49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer type around std::FILE.  <a href="namespaceLLU.html#a69b7b156baa9302492eb6a7b7cedf49a">More...</a><br /></td></tr>
<tr class="separator:a69b7b156baa9302492eb6a7b7cedf49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca71eb0f530752a0e37235c19c1d247"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ca71eb0f530752a0e37235c19c1d247"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a6ca71eb0f530752a0e37235c19c1d247">remove_cv_ref</a> = std::remove_cv_t&lt; std::remove_reference_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a6ca71eb0f530752a0e37235c19c1d247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that strips any given type from reference and cv qualifiers.  <a href="namespaceLLU.html#a6ca71eb0f530752a0e37235c19c1d247">More...</a><br /></td></tr>
<tr class="separator:a6ca71eb0f530752a0e37235c19c1d247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace313dc3d98be9f67fb4af17f830d8be"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ace313dc3d98be9f67fb4af17f830d8be"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#ace313dc3d98be9f67fb4af17f830d8be">disable_if_same_or_derived</a> = typename std::enable_if_t&lt;!std::is_same&lt; A, B &gt;::value &amp;&amp;!std::is_base_of&lt; A, <a class="el" href="namespaceLLU.html#a6ca71eb0f530752a0e37235c19c1d247">remove_cv_ref</a>&lt; B &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ace313dc3d98be9f67fb4af17f830d8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that is valid only if B is not A and not a subclass of A.  <a href="namespaceLLU.html#ace313dc3d98be9f67fb4af17f830d8be">More...</a><br /></td></tr>
<tr class="separator:ace313dc3d98be9f67fb4af17f830d8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13b03e925850175d5f4225c1403fcb5"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af13b03e925850175d5f4225c1403fcb5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#af13b03e925850175d5f4225c1403fcb5">enable_if_same_or_derived</a> = typename std::enable_if_t&lt; std::is_same&lt; A, B &gt;::value||std::is_base_of&lt; A, <a class="el" href="namespaceLLU.html#a6ca71eb0f530752a0e37235c19c1d247">remove_cv_ref</a>&lt; B &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:af13b03e925850175d5f4225c1403fcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that is valid only if B is A or a subclass of A.  <a href="namespaceLLU.html#af13b03e925850175d5f4225c1403fcb5">More...</a><br /></td></tr>
<tr class="separator:af13b03e925850175d5f4225c1403fcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066af46e94a6a3c02c0387d6c6fa93c6"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a066af46e94a6a3c02c0387d6c6fa93c6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a066af46e94a6a3c02c0387d6c6fa93c6">enable_if_input_iterator</a> = <a class="el" href="namespaceLLU.html#af13b03e925850175d5f4225c1403fcb5">enable_if_same_or_derived</a>&lt; std::input_iterator_tag, typename std::iterator_traits&lt; Iterator &gt;::iterator_category &gt;</td></tr>
<tr class="memdesc:a066af46e94a6a3c02c0387d6c6fa93c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that checks if given type can be treated as input iterator.  <a href="namespaceLLU.html#a066af46e94a6a3c02c0387d6c6fa93c6">More...</a><br /></td></tr>
<tr class="separator:a066af46e94a6a3c02c0387d6c6fa93c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e9cf1342de5a8ea1d850b6eabeb238"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ad6e9cf1342de5a8ea1d850b6eabeb238"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#ad6e9cf1342de5a8ea1d850b6eabeb238">enable_if_integral_elements</a> = typename std::enable_if_t&lt; std::is_integral&lt; typename std::remove_reference_t&lt; Container &gt;::value_type &gt;::value &gt;</td></tr>
<tr class="memdesc:ad6e9cf1342de5a8ea1d850b6eabeb238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility type that checks if given container type has elements that are integers (and therefore can be used as <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> or <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> dimensions)  <a href="namespaceLLU.html#ad6e9cf1342de5a8ea1d850b6eabeb238">More...</a><br /></td></tr>
<tr class="separator:ad6e9cf1342de5a8ea1d850b6eabeb238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095ed39463f5e284a9f55064b1f6d4ec"><td class="memTemplParams" colspan="2">template&lt;numericarray_data_t rat&gt; </td></tr>
<tr class="memitem:a095ed39463f5e284a9f55064b1f6d4ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a095ed39463f5e284a9f55064b1f6d4ec">NumericArrayTypeFromEnum</a> = typename <a class="el" href="structLLU_1_1NumericArrayFromEnum.html">NumericArrayFromEnum</a>&lt; rat &gt;::type</td></tr>
<tr class="memdesc:a095ed39463f5e284a9f55064b1f6d4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple type alias to easily extract type from <a class="el" href="structLLU_1_1NumericArrayFromEnum.html" title="Utility structure that matches an MNumericArray data type with corresponding C++ type.">NumericArrayFromEnum</a>.  <a href="namespaceLLU.html#a095ed39463f5e284a9f55064b1f6d4ec">More...</a><br /></td></tr>
<tr class="separator:a095ed39463f5e284a9f55064b1f6d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a046343d3a2eebf70fd1b042ebfecadae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a046343d3a2eebf70fd1b042ebfecadae">Ownership</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceLLU.html#a046343d3a2eebf70fd1b042ebfecadaea288ee6322c093edabf6d391c4ce49484">Ownership::LibraryLink</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceLLU.html#a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be">Ownership::Library</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceLLU.html#a046343d3a2eebf70fd1b042ebfecadaeaa6156ea9d66fef24e87e841fbabf7cca">Ownership::Shared</a>
<br />
 }</td></tr>
<tr class="memdesc:a046343d3a2eebf70fd1b042ebfecadae"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum listing possible owners of a LibraryLink container.  <a href="namespaceLLU.html#a046343d3a2eebf70fd1b042ebfecadae">More...</a><br /></td></tr>
<tr class="separator:a046343d3a2eebf70fd1b042ebfecadae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1820c98edfdbceb11ed54c902fe9df"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a6f1820c98edfdbceb11ed54c902fe9df">MArgumentType</a> { <br />
&#160;&#160;<b>MArgument</b> = MType_Undef, 
<br />
&#160;&#160;<b>Boolean</b> = MType_Boolean, 
<br />
&#160;&#160;<b>Integer</b> = MType_Integer, 
<br />
&#160;&#160;<b>Real</b> = MType_Real, 
<br />
&#160;&#160;<b>Complex</b> = MType_Complex, 
<br />
&#160;&#160;<b>Tensor</b> = MType_Tensor, 
<br />
&#160;&#160;<b>SparseArray</b> = MType_SparseArray, 
<br />
&#160;&#160;<b>NumericArray</b> = MType_NumericArray, 
<br />
&#160;&#160;<b>Image</b> = MType_Image, 
<br />
&#160;&#160;<b>UTF8String</b> = MType_UTF8String, 
<br />
&#160;&#160;<b>DataStore</b> = MType_DataStore
<br />
 }</td></tr>
<tr class="memdesc:a6f1820c98edfdbceb11ed54c902fe9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strongly type enum with possible types of data stored in MArgument.  <a href="namespaceLLU.html#a6f1820c98edfdbceb11ed54c902fe9df">More...</a><br /></td></tr>
<tr class="separator:a6f1820c98edfdbceb11ed54c902fe9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cec82f659ea12a4ad464a4dba7ca4fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a3cec82f659ea12a4ad464a4dba7ca4fc">Passing</a> { <br />
&#160;&#160;<b>Automatic</b>, 
<br />
&#160;&#160;<b>Constant</b>, 
<br />
&#160;&#160;<b>Manual</b>, 
<br />
&#160;&#160;<b>Shared</b>
<br />
 }</td></tr>
<tr class="memdesc:a3cec82f659ea12a4ad464a4dba7ca4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerated type representing different modes in which a container can be passed from LibraryLink to the library.  <a href="namespaceLLU.html#a3cec82f659ea12a4ad464a4dba7ca4fc">More...</a><br /></td></tr>
<tr class="separator:a3cec82f659ea12a4ad464a4dba7ca4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6507f4ce974332a965f18a6551d7b6c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6507f4ce974332a965f18a6551d7b6c5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a6507f4ce974332a965f18a6551d7b6c5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classLLU_1_1MArray.html">MArray</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="memdesc:a6507f4ce974332a965f18a6551d7b6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insertion operator to allow pretty-printing of <a class="el" href="classLLU_1_1MArray.html" title="This is a class template, where template parameter T is the type of data elements....">MArray</a>.  <a href="namespaceLLU.html#a6507f4ce974332a965f18a6551d7b6c5">More...</a><br /></td></tr>
<tr class="separator:a6507f4ce974332a965f18a6551d7b6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b98f1b11b2bf0a4fa47952e02df8cd"><td class="memTemplParams" colspan="2">template&lt;typename ImageT , typename F &gt; </td></tr>
<tr class="memitem:a63b98f1b11b2bf0a4fa47952e02df8cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a63b98f1b11b2bf0a4fa47952e02df8cd">asTypedImage</a> (ImageT &amp;&amp;img, F &amp;&amp;callable)</td></tr>
<tr class="memdesc:a63b98f1b11b2bf0a4fa47952e02df8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a Image-like object <code>img</code> and a function <code>callable</code> and call the function with a ImageTypedView created from <code>img</code>.  <a href="namespaceLLU.html#a63b98f1b11b2bf0a4fa47952e02df8cd">More...</a><br /></td></tr>
<tr class="separator:a63b98f1b11b2bf0a4fa47952e02df8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774de8facff788ab23f7ba1cba545faa"><td class="memTemplParams" colspan="2">template&lt;typename NumericArrayT , typename F &gt; </td></tr>
<tr class="memitem:a774de8facff788ab23f7ba1cba545faa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a774de8facff788ab23f7ba1cba545faa">asTypedNumericArray</a> (NumericArrayT &amp;&amp;na, F &amp;&amp;callable)</td></tr>
<tr class="memdesc:a774de8facff788ab23f7ba1cba545faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a NumericArray-like object <code>na</code> and a function <code>callable</code> and call the function with a <a class="el" href="classLLU_1_1NumericArrayTypedView.html" title="Simple, light-weight, non-owning wrappper over MNumericArray.">NumericArrayTypedView</a> created from <code>na</code>.  <a href="namespaceLLU.html#a774de8facff788ab23f7ba1cba545faa">More...</a><br /></td></tr>
<tr class="separator:a774de8facff788ab23f7ba1cba545faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dcef843ace924ca56e722a224922e9"><td class="memTemplParams" colspan="2">template&lt;typename TensorT , typename F &gt; </td></tr>
<tr class="memitem:a38dcef843ace924ca56e722a224922e9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a38dcef843ace924ca56e722a224922e9">asTypedTensor</a> (TensorT &amp;&amp;t, F &amp;&amp;callable)</td></tr>
<tr class="memdesc:a38dcef843ace924ca56e722a224922e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a Tensor-like object <code>t</code> and a function <code>callable</code> and call the function with a TensorTypedView created from <code>t</code>.  <a href="namespaceLLU.html#a38dcef843ace924ca56e722a224922e9">More...</a><br /></td></tr>
<tr class="separator:a38dcef843ace924ca56e722a224922e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a7e004a1504bac715222ed3bedbe82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceLLU.html#a69b7b156baa9302492eb6a7b7cedf49a">FilePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#ac8a7e004a1504bac715222ed3bedbe82">claimFile</a> (std::FILE *f)</td></tr>
<tr class="memdesc:ac8a7e004a1504bac715222ed3bedbe82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique owning pointer of a FILE.  <a href="namespaceLLU.html#ac8a7e004a1504bac715222ed3bedbe82">More...</a><br /></td></tr>
<tr class="separator:ac8a7e004a1504bac715222ed3bedbe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa527ce949d7addf85262fd48c04159a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#aa527ce949d7addf85262fd48c04159a8">validatePath</a> (const std::string &amp;fileName, std::ios::openmode mode)</td></tr>
<tr class="memdesc:aa527ce949d7addf85262fd48c04159a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file <code>fileName</code> under open mode <code>mode</code> is accessible in the current sandbox setting.  <a href="namespaceLLU.html#aa527ce949d7addf85262fd48c04159a8">More...</a><br /></td></tr>
<tr class="separator:aa527ce949d7addf85262fd48c04159a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeeb9ed2af0bf29acd166b21b2c2bf79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeeeb9ed2af0bf29acd166b21b2c2bf79"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#aeeeb9ed2af0bf29acd166b21b2c2bf79">fromUTF8toUTF16</a> (const std::string &amp;source)</td></tr>
<tr class="memdesc:aeeeb9ed2af0bf29acd166b21b2c2bf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string from UTF8 to UTF16.  <a href="namespaceLLU.html#aeeeb9ed2af0bf29acd166b21b2c2bf79">More...</a><br /></td></tr>
<tr class="separator:aeeeb9ed2af0bf29acd166b21b2c2bf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20969eeaaea91d44253c88b42fdde2c7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20969eeaaea91d44253c88b42fdde2c7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a20969eeaaea91d44253c88b42fdde2c7">fromUTF16toUTF8</a> (const std::basic_string&lt; T &gt; &amp;source)</td></tr>
<tr class="memdesc:a20969eeaaea91d44253c88b42fdde2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string from UTF16 to UTF8.  <a href="namespaceLLU.html#a20969eeaaea91d44253c88b42fdde2c7">More...</a><br /></td></tr>
<tr class="separator:a20969eeaaea91d44253c88b42fdde2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38a83d7f462737841e591d137c6f146"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac38a83d7f462737841e591d137c6f146"><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#ac38a83d7f462737841e591d137c6f146">fromUTF8toUTF32</a> (const std::string &amp;source)</td></tr>
<tr class="memdesc:ac38a83d7f462737841e591d137c6f146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string from UTF8 to UTF32.  <a href="namespaceLLU.html#ac38a83d7f462737841e591d137c6f146">More...</a><br /></td></tr>
<tr class="separator:ac38a83d7f462737841e591d137c6f146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2c9ac2e5611288fbd5248316f5c3e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a2c9ac2e5611288fbd5248316f5c3e8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a1a2c9ac2e5611288fbd5248316f5c3e8">fromUTF32toUTF8</a> (const std::basic_string&lt; T &gt; &amp;source)</td></tr>
<tr class="memdesc:a1a2c9ac2e5611288fbd5248316f5c3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string from UTF32 to UTF8.  <a href="namespaceLLU.html#a1a2c9ac2e5611288fbd5248316f5c3e8">More...</a><br /></td></tr>
<tr class="separator:a1a2c9ac2e5611288fbd5248316f5c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe77f7de2bcfa22a61972162fcc4926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceLLU.html#a69b7b156baa9302492eb6a7b7cedf49a">FilePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a2fe77f7de2bcfa22a61972162fcc4926">openFile</a> (const std::string &amp;fileName, std::ios::openmode mode, const <a class="el" href="structLLU_1_1SharePolicy.html">SharePolicy</a> &amp;shp=<a class="el" href="structLLU_1_1AlwaysReadExclusiveWrite.html">AlwaysReadExclusiveWrite</a> {})</td></tr>
<tr class="memdesc:a2fe77f7de2bcfa22a61972162fcc4926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open given file with specified mode (read, write, append, etc.).  <a href="namespaceLLU.html#a2fe77f7de2bcfa22a61972162fcc4926">More...</a><br /></td></tr>
<tr class="separator:a2fe77f7de2bcfa22a61972162fcc4926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9016456b50c299c9bcefd407010a0488"><td class="memItemLeft" align="right" valign="top">std::fstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a9016456b50c299c9bcefd407010a0488">openFileStream</a> (const std::string &amp;fileName, std::ios::openmode mode, const <a class="el" href="structLLU_1_1SharePolicy.html">SharePolicy</a> &amp;shp=<a class="el" href="structLLU_1_1AlwaysReadExclusiveWrite.html">AlwaysReadExclusiveWrite</a> {})</td></tr>
<tr class="memdesc:a9016456b50c299c9bcefd407010a0488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file stream with specified mode (read, write, append, etc.).  <a href="namespaceLLU.html#a9016456b50c299c9bcefd407010a0488">More...</a><br /></td></tr>
<tr class="separator:a9016456b50c299c9bcefd407010a0488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7dd018149857ca8efb5cb6ce51ff12"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2c7dd018149857ca8efb5cb6ce51ff12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a2c7dd018149857ca8efb5cb6ce51ff12">manageInstanceCallback</a> (WolframLibraryData, mbool, mint)</td></tr>
<tr class="memdesc:a2c7dd018149857ca8efb5cb6ce51ff12"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for library callback used by LibraryLink to manage instances of ManagedLibraryExpressions.  <a href="namespaceLLU.html#a2c7dd018149857ca8efb5cb6ce51ff12">More...</a><br /></td></tr>
<tr class="separator:a2c7dd018149857ca8efb5cb6ce51ff12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85531f89f239a010ea002a6fb2611217"><td class="memTemplParams" colspan="2">template&lt;typename VariantType , typename T , std::size_t index = 0&gt; </td></tr>
<tr class="memitem:a85531f89f239a010ea002a6fb2611217"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a85531f89f239a010ea002a6fb2611217">variant_index</a> ()</td></tr>
<tr class="memdesc:a85531f89f239a010ea002a6fb2611217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get index of given type in the variant.  <a href="namespaceLLU.html#a85531f89f239a010ea002a6fb2611217">More...</a><br /></td></tr>
<tr class="separator:a85531f89f239a010ea002a6fb2611217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aedc692c1bacf554b1f141e16c669a9"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9aedc692c1bacf554b1f141e16c669a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a9aedc692c1bacf554b1f141e16c669a9">Unused</a> (Ts &amp;&amp;...)</td></tr>
<tr class="memdesc:a9aedc692c1bacf554b1f141e16c669a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy function called on otherwise unused parameters to eliminate compiler warnings.  <a href="namespaceLLU.html#a9aedc692c1bacf554b1f141e16c669a9">More...</a><br /></td></tr>
<tr class="separator:a9aedc692c1bacf554b1f141e16c669a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88589493c6a906a84503c7261590e00d"><td class="memItemLeft" align="right" valign="top">EXTERN_C DLLEXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a88589493c6a906a84503c7261590e00d">sendRegisteredErrors</a> ([[maybe_unused]] WolframLibraryData libData, WSLINK mlp)</td></tr>
<tr class="memdesc:a88589493c6a906a84503c7261590e00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LibraryLink function that <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> will call to send all errors registered in C++ to the Wolfram Language layer.  <a href="namespaceLLU.html#a88589493c6a906a84503c7261590e00d">More...</a><br /></td></tr>
<tr class="separator:a88589493c6a906a84503c7261590e00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87045f6894f622664b4f8c0df15d96b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#ae87045f6894f622664b4f8c0df15d96b">LIBRARY_LINK_FUNCTION</a> (setExceptionDetailsContext)</td></tr>
<tr class="memdesc:ae87045f6894f622664b4f8c0df15d96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">LibraryLink function that <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> will call to set the context for the symbol, to which exception details are assigned.  <a href="namespaceLLU.html#ae87045f6894f622664b4f8c0df15d96b">More...</a><br /></td></tr>
<tr class="separator:ae87045f6894f622664b4f8c0df15d96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cd388ae60de31cb8b3ef9678bbba06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a86cd388ae60de31cb8b3ef9678bbba06">LIBRARY_LINK_FUNCTION</a> (setLoggerContext)</td></tr>
<tr class="memdesc:a86cd388ae60de31cb8b3ef9678bbba06"><td class="mdescLeft">&#160;</td><td class="mdescRight">LibraryLink function that <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> will call to set the context for the symbol, to which log details are assigned.  <a href="namespaceLLU.html#a86cd388ae60de31cb8b3ef9678bbba06">More...</a><br /></td></tr>
<tr class="separator:a86cd388ae60de31cb8b3ef9678bbba06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a526ba20abeaf0370d8b5cbbd2a058d67"><td class="memTemplParams" colspan="2">template&lt;MArgumentType T&gt; </td></tr>
<tr class="memitem:a526ba20abeaf0370d8b5cbbd2a058d67"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a526ba20abeaf0370d8b5cbbd2a058d67">alwaysFalse</a> = false</td></tr>
<tr class="memdesc:a526ba20abeaf0370d8b5cbbd2a058d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template variable that is always false.  <a href="namespaceLLU.html#a526ba20abeaf0370d8b5cbbd2a058d67">More...</a><br /></td></tr>
<tr class="separator:a526ba20abeaf0370d8b5cbbd2a058d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f753d24e80a5fdb0a604de9b6df781"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a03f753d24e80a5fdb0a604de9b6df781"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a03f753d24e80a5fdb0a604de9b6df781">has_size_v</a> = has_size&lt;Container&gt;::value</td></tr>
<tr class="memdesc:a03f753d24e80a5fdb0a604de9b6df781"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait to check whether type <code>Container</code> has a member function <code>size()</code>  <a href="namespaceLLU.html#a03f753d24e80a5fdb0a604de9b6df781">More...</a><br /></td></tr>
<tr class="separator:a03f753d24e80a5fdb0a604de9b6df781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc06f6339203269fdc77dfb2b15a499"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:afbc06f6339203269fdc77dfb2b15a499"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#afbc06f6339203269fdc77dfb2b15a499">is_iterable_container_with_matching_type_v</a></td></tr>
<tr class="memdesc:afbc06f6339203269fdc77dfb2b15a499"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait to check whether type <code>Container</code> is a class type with a member type alias <code>value_type</code> equal to T and with begin() and end() methods.  <a href="namespaceLLU.html#afbc06f6339203269fdc77dfb2b15a499">More...</a><br /></td></tr>
<tr class="separator:afbc06f6339203269fdc77dfb2b15a499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1a2c0ed927b6b294a3653be46640f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d1a2c0ed927b6b294a3653be46640f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a2d1a2c0ed927b6b294a3653be46640f6">dependent_false_v</a> = <a class="el" href="structLLU_1_1dependent__false.html">dependent_false</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a2d1a2c0ed927b6b294a3653be46640f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time boolean constant false that "depends" on a template parameter.  <a href="namespaceLLU.html#a2d1a2c0ed927b6b294a3653be46640f6">More...</a><br /></td></tr>
<tr class="separator:a2d1a2c0ed927b6b294a3653be46640f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac859e1bc45cedcaa3017bc9cc039160"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac859e1bc45cedcaa3017bc9cc039160"><td class="memTemplItemLeft" align="right" valign="top">constexpr imagedata_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#aac859e1bc45cedcaa3017bc9cc039160">ImageType</a> = MImage_Type_Undef</td></tr>
<tr class="memdesc:aac859e1bc45cedcaa3017bc9cc039160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility variable template that matches a C++ type with a corresponding MImage data type.  <a href="namespaceLLU.html#aac859e1bc45cedcaa3017bc9cc039160">More...</a><br /></td></tr>
<tr class="separator:aac859e1bc45cedcaa3017bc9cc039160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588365d600f8b9384e4006db8bafa98a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a588365d600f8b9384e4006db8bafa98a"><td class="memTemplItemLeft" align="right" valign="top">constexpr numericarray_data_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a588365d600f8b9384e4006db8bafa98a">NumericArrayType</a> = MNumericArray_Type_Undef</td></tr>
<tr class="memdesc:a588365d600f8b9384e4006db8bafa98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility structure that matches a C++ type with a corresponding MNumericArray data type.  <a href="namespaceLLU.html#a588365d600f8b9384e4006db8bafa98a">More...</a><br /></td></tr>
<tr class="separator:a588365d600f8b9384e4006db8bafa98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb7ca8417bb1bb81cf349c2f1f44e97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1bb7ca8417bb1bb81cf349c2f1f44e97"><td class="memTemplItemLeft" align="right" valign="top">constexpr mint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLLU.html#a1bb7ca8417bb1bb81cf349c2f1f44e97">TensorType</a> = MType_Undef</td></tr>
<tr class="memdesc:a1bb7ca8417bb1bb81cf349c2f1f44e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility structure that matches a C++ type with a corresponding MTensor data type.  <a href="namespaceLLU.html#a1bb7ca8417bb1bb81cf349c2f1f44e97">More...</a><br /></td></tr>
<tr class="separator:a1bb7ca8417bb1bb81cf349c2f1f44e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Type aliases documentation</h2>
<a id="ae9b523e0cd42c388792d850579518319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b523e0cd42c388792d850579518319">&#9670;&nbsp;</a></span>BasicPool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#ae9b523e0cd42c388792d850579518319">LLU::BasicPool</a> = typedef <a class="el" href="classLLU_1_1Async_1_1BasicThreadPool.html">Async::BasicThreadPool</a>&lt;<a class="el" href="classLLU_1_1Async_1_1ThreadsafeQueue.html">Async::ThreadsafeQueue</a>&lt;<a class="el" href="classLLU_1_1Async_1_1FunctionWrapper.html">Async::FunctionWrapper</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for BasicThreadPool with ThreadsafeQueue storing Async::FunctionWrappers. </p>
<p>Good default choice for a thread pool for any paclet. </p>

</div>
</div>
<a id="ace313dc3d98be9f67fb4af17f830d8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace313dc3d98be9f67fb4af17f830d8be">&#9670;&nbsp;</a></span>disable_if_same_or_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#ace313dc3d98be9f67fb4af17f830d8be">LLU::disable_if_same_or_derived</a> = typedef typename std::enable_if_t&lt;!std::is_same&lt;A, B&gt;::value &amp;&amp; !std::is_base_of&lt;A, <a class="el" href="namespaceLLU.html#a6ca71eb0f530752a0e37235c19c1d247">remove_cv_ref</a>&lt;B&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility type that is valid only if B is not A and not a subclass of A. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- any type </td></tr>
    <tr><td class="paramname">B</td><td>- any type, will be stripped of reference and cv-qualifiers before comparing with A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a066af46e94a6a3c02c0387d6c6fa93c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066af46e94a6a3c02c0387d6c6fa93c6">&#9670;&nbsp;</a></span>enable_if_input_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#a066af46e94a6a3c02c0387d6c6fa93c6">LLU::enable_if_input_iterator</a> = typedef <a class="el" href="namespaceLLU.html#af13b03e925850175d5f4225c1403fcb5">enable_if_same_or_derived</a>&lt;std::input_iterator_tag, typename std::iterator_traits&lt;Iterator&gt;::iterator_category&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility type that checks if given type can be treated as input iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>- iterator type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6e9cf1342de5a8ea1d850b6eabeb238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e9cf1342de5a8ea1d850b6eabeb238">&#9670;&nbsp;</a></span>enable_if_integral_elements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#ad6e9cf1342de5a8ea1d850b6eabeb238">LLU::enable_if_integral_elements</a> = typedef typename std::enable_if_t&lt;std::is_integral&lt;typename std::remove_reference_t&lt;Container&gt;::value_type&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility type that checks if given container type has elements that are integers (and therefore can be used as <a class="el" href="classLLU_1_1Tensor.html" title="This is a class template, where template parameter T is the type of data elements....">Tensor</a> or <a class="el" href="classLLU_1_1NumericArray.html" title="This is a class template, where template parameter T is the type of data elements....">NumericArray</a> dimensions) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>- container type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af13b03e925850175d5f4225c1403fcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13b03e925850175d5f4225c1403fcb5">&#9670;&nbsp;</a></span>enable_if_same_or_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#af13b03e925850175d5f4225c1403fcb5">LLU::enable_if_same_or_derived</a> = typedef typename std::enable_if_t&lt;std::is_same&lt;A, B&gt;::value || std::is_base_of&lt;A, <a class="el" href="namespaceLLU.html#a6ca71eb0f530752a0e37235c19c1d247">remove_cv_ref</a>&lt;B&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility type that is valid only if B is A or a subclass of A. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>- any type </td></tr>
    <tr><td class="paramname">B</td><td>- any type, will be stripped of reference and cv-qualifiers before comparing with A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69b7b156baa9302492eb6a7b7cedf49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b7b156baa9302492eb6a7b7cedf49a">&#9670;&nbsp;</a></span>FilePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#a69b7b156baa9302492eb6a7b7cedf49a">LLU::FilePtr</a> = typedef std::unique_ptr&lt;std::FILE, int (*)(std::FILE*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smart pointer type around std::FILE. </p>

</div>
</div>
<a id="a4a9e8e31bf555d15928845a173704aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9e8e31bf555d15928845a173704aa9">&#9670;&nbsp;</a></span>GenericDataList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#a4a9e8e31bf555d15928845a173704aa9">LLU::GenericDataList</a> = typedef <a class="el" href="classLLU_1_1MContainer.html">MContainer</a>&lt;MArgumentType::DataStore&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for DataStore is called GenericDataList. </p>

</div>
</div>
<a id="a7013557ff73aaad19a9a5411520be837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7013557ff73aaad19a9a5411520be837">&#9670;&nbsp;</a></span>GenericImage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#a7013557ff73aaad19a9a5411520be837">LLU::GenericImage</a> = typedef <a class="el" href="classLLU_1_1MContainer.html">MContainer</a>&lt;MArgumentType::Image&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MImage is called GenericImage. </p>

</div>
</div>
<a id="ac246fc9334d25bf0df9d08f0bfb8927d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac246fc9334d25bf0df9d08f0bfb8927d">&#9670;&nbsp;</a></span>GenericNumericArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#ac246fc9334d25bf0df9d08f0bfb8927d">LLU::GenericNumericArray</a> = typedef <a class="el" href="classLLU_1_1MContainer.html">MContainer</a>&lt;MArgumentType::NumericArray&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MNumericArray is called GenericNumericArray. </p>

</div>
</div>
<a id="aa463b81b42bbdd7c6fb53e32132e0a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa463b81b42bbdd7c6fb53e32132e0a2f">&#9670;&nbsp;</a></span>GenericTensor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#aa463b81b42bbdd7c6fb53e32132e0a2f">LLU::GenericTensor</a> = typedef <a class="el" href="classLLU_1_1MContainer.html">MContainer</a>&lt;MArgumentType::Tensor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classLLU_1_1MContainer.html" title="MContainer is an abstract class template for generic containers.&#160;Only specializations shall be used.">MContainer</a> specialization for MTensor is called GenericTensor. </p>

</div>
</div>
<a id="a095ed39463f5e284a9f55064b1f6d4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095ed39463f5e284a9f55064b1f6d4ec">&#9670;&nbsp;</a></span>NumericArrayTypeFromEnum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;numericarray_data_t rat&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#a095ed39463f5e284a9f55064b1f6d4ec">LLU::NumericArrayTypeFromEnum</a> = typedef typename <a class="el" href="structLLU_1_1NumericArrayFromEnum.html">NumericArrayFromEnum</a>&lt;rat&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple type alias to easily extract type from <a class="el" href="structLLU_1_1NumericArrayFromEnum.html" title="Utility structure that matches an MNumericArray data type with corresponding C++ type.">NumericArrayFromEnum</a>. </p>

</div>
</div>
<a id="a6ca71eb0f530752a0e37235c19c1d247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca71eb0f530752a0e37235c19c1d247">&#9670;&nbsp;</a></span>remove_cv_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#a6ca71eb0f530752a0e37235c19c1d247">LLU::remove_cv_ref</a> = typedef std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility type that strips any given type from reference and cv qualifiers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- any type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a970fbec367bc4714ac2b9d210d649f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970fbec367bc4714ac2b9d210d649f55">&#9670;&nbsp;</a></span>ThreadPool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLLU.html#a970fbec367bc4714ac2b9d210d649f55">LLU::ThreadPool</a> = typedef <a class="el" href="classLLU_1_1Async_1_1GenericThreadPool.html">Async::GenericThreadPool</a>&lt;<a class="el" href="classLLU_1_1Async_1_1ThreadsafeQueue.html">Async::ThreadsafeQueue</a>&lt;<a class="el" href="classLLU_1_1Async_1_1FunctionWrapper.html">Async::FunctionWrapper</a>&gt;, <a class="el" href="classLLU_1_1Async_1_1WorkStealingQueue.html">Async::WorkStealingQueue</a>&lt;std::deque&lt;<a class="el" href="classLLU_1_1Async_1_1FunctionWrapper.html">Async::FunctionWrapper</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for GenericThreadPool with ThreadsafeQueue and WorkStealingQueue storing Async::FunctionWrappers. </p>
<p>Good choice for a thread pool if the tasks that will be executed involve submitting new tasks for the pool. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6f1820c98edfdbceb11ed54c902fe9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1820c98edfdbceb11ed54c902fe9df">&#9670;&nbsp;</a></span>MArgumentType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceLLU.html#a6f1820c98edfdbceb11ed54c902fe9df">LLU::MArgumentType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strongly type enum with possible types of data stored in MArgument. </p>

</div>
</div>
<a id="a046343d3a2eebf70fd1b042ebfecadae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046343d3a2eebf70fd1b042ebfecadae">&#9670;&nbsp;</a></span>Ownership</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceLLU.html#a046343d3a2eebf70fd1b042ebfecadae">LLU::Ownership</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum listing possible owners of a LibraryLink container. </p>
<p>Ownership determines the memory management of a container. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a046343d3a2eebf70fd1b042ebfecadaea288ee6322c093edabf6d391c4ce49484"></a>LibraryLink&#160;</td><td class="fielddoc"><p>LibraryLink is responsible for managing the container's memory. Corresponds to Automatic and "Constant" passing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a046343d3a2eebf70fd1b042ebfecadaea4d70254b3a8e2bc38b6147fa6ee813be"></a>Library&#160;</td><td class="fielddoc"><p>The library (<a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a>) is responsible for managing the container's memory. Used for Manual passing and containers created by the library. </p>
</td></tr>
<tr><td class="fieldname"><a id="a046343d3a2eebf70fd1b042ebfecadaeaa6156ea9d66fef24e87e841fbabf7cca"></a>Shared&#160;</td><td class="fielddoc"><p>When the container is shared <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> only needs to decrease share count when it's done. Only used for arguments passed as "Shared". </p>
</td></tr>
</table>

</div>
</div>
<a id="a3cec82f659ea12a4ad464a4dba7ca4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cec82f659ea12a4ad464a4dba7ca4fc">&#9670;&nbsp;</a></span>Passing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceLLU.html#a3cec82f659ea12a4ad464a4dba7ca4fc">LLU::Passing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerated type representing different modes in which a container can be passed from LibraryLink to the library. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#97446640">https://reference.wolfram.com/language/LibraryLink/tutorial/InteractionWithWolframLanguage.html#97446640</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a63b98f1b11b2bf0a4fa47952e02df8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b98f1b11b2bf0a4fa47952e02df8cd">&#9670;&nbsp;</a></span>asTypedImage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ImageT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto LLU::asTypedImage </td>
          <td>(</td>
          <td class="paramtype">ImageT &amp;&amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a Image-like object <code>img</code> and a function <code>callable</code> and call the function with a ImageTypedView created from <code>img</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ImageT</td><td>- a Image-like type (GenericImage, <a class="el" href="classLLU_1_1ImageView.html" title="Simple, light-weight, non-owning wrappper over MImage.">ImageView</a> or MNumericAray) </td></tr>
    <tr><td class="paramname">F</td><td>- any callable object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>- Image-like object on which an operation will be performed </td></tr>
    <tr><td class="paramname">callable</td><td>- a callable object that can be called with a ImageTypedView of any type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of calling <code>callable</code> on a ImageTypedView over <code>img</code> </dd></dl>

</div>
</div>
<a id="a774de8facff788ab23f7ba1cba545faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774de8facff788ab23f7ba1cba545faa">&#9670;&nbsp;</a></span>asTypedNumericArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericArrayT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto LLU::asTypedNumericArray </td>
          <td>(</td>
          <td class="paramtype">NumericArrayT &amp;&amp;&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a NumericArray-like object <code>na</code> and a function <code>callable</code> and call the function with a <a class="el" href="classLLU_1_1NumericArrayTypedView.html" title="Simple, light-weight, non-owning wrappper over MNumericArray.">NumericArrayTypedView</a> created from <code>na</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumericArrayT</td><td>- a NumericArray-like type (GenericNumericArray, <a class="el" href="classLLU_1_1NumericArrayView.html" title="Simple, light-weight, non-owning, data-type-agnostic wrappper over MNumericArray.">NumericArrayView</a> or MNumericAray) </td></tr>
    <tr><td class="paramname">F</td><td>- any callable object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">na</td><td>- NumericArray-like object on which an operation will be performed </td></tr>
    <tr><td class="paramname">callable</td><td>- a callable object that can be called with a <a class="el" href="classLLU_1_1NumericArrayTypedView.html" title="Simple, light-weight, non-owning wrappper over MNumericArray.">NumericArrayTypedView</a> of any type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of calling <code>callable</code> on a <a class="el" href="classLLU_1_1NumericArrayTypedView.html" title="Simple, light-weight, non-owning wrappper over MNumericArray.">NumericArrayTypedView</a> over <code>na</code> </dd></dl>

</div>
</div>
<a id="a38dcef843ace924ca56e722a224922e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dcef843ace924ca56e722a224922e9">&#9670;&nbsp;</a></span>asTypedTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorT , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto LLU::asTypedTensor </td>
          <td>(</td>
          <td class="paramtype">TensorT &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>callable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a Tensor-like object <code>t</code> and a function <code>callable</code> and call the function with a TensorTypedView created from <code>t</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorT</td><td>- a Tensor-like type (GenericTensor, <a class="el" href="classLLU_1_1TensorView.html" title="Simple, light-weight, non-owning wrappper over MTensor.">TensorView</a> or MNumericAray) </td></tr>
    <tr><td class="paramname">F</td><td>- any callable object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>- Tensor-like object on which an operation will be performed </td></tr>
    <tr><td class="paramname">callable</td><td>- a callable object that can be called with a TensorTypedView of any type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of calling <code>callable</code> on a TensorTypedView over <code>t</code> </dd></dl>

</div>
</div>
<a id="ac8a7e004a1504bac715222ed3bedbe82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a7e004a1504bac715222ed3bedbe82">&#9670;&nbsp;</a></span>claimFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLLU.html#a69b7b156baa9302492eb6a7b7cedf49a">FilePtr</a> LLU::claimFile </td>
          <td>(</td>
          <td class="paramtype">std::FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique owning pointer of a FILE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- a stream pointer obtained from fopen </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a smart pointer owning <code>f</code> that will call <code>fclose</code> on <code>f</code> in destructor </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if <code>f</code> is not a result of <code>fopen</code>, the behavior is undefined </dd></dl>

</div>
</div>
<a id="a20969eeaaea91d44253c88b42fdde2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20969eeaaea91d44253c88b42fdde2c7">&#9670;&nbsp;</a></span>fromUTF16toUTF8()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LLU::fromUTF16toUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string from UTF16 to UTF8. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- character type of the UTF16 string, supported types are char16_t, char32_t, or wchar_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- string in UTF16 encoding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the input string converted to UTF8 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>char16_t and char32_t strings on Windows will be converted to std::wstring before encoding conversion due to a bug in VS2017 </dd></dl>

</div>
</div>
<a id="a1a2c9ac2e5611288fbd5248316f5c3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2c9ac2e5611288fbd5248316f5c3e8">&#9670;&nbsp;</a></span>fromUTF32toUTF8()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LLU::fromUTF32toUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string from UTF32 to UTF8. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- character type of the UTF32 string </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- string in UTF32 encoding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the input string converted to UTF8 </dd></dl>

</div>
</div>
<a id="aeeeb9ed2af0bf29acd166b21b2c2bf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeeb9ed2af0bf29acd166b21b2c2bf79">&#9670;&nbsp;</a></span>fromUTF8toUTF16()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;T&gt; LLU::fromUTF8toUTF16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string from UTF8 to UTF16. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- character type for the result, supported types are char16_t, char32_t, or wchar_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- string in UTF8 encoding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the input string converted to UTF16 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>char16_t and char32_t strings on Windows will be converted to a temporary std::wstring first due to a bug in VS2017 </dd></dl>

</div>
</div>
<a id="ac38a83d7f462737841e591d137c6f146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38a83d7f462737841e591d137c6f146">&#9670;&nbsp;</a></span>fromUTF8toUTF32()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;T&gt; LLU::fromUTF8toUTF32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string from UTF8 to UTF32. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- character type for the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>- string in UTF8 encoding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the input string converted to UTF32 </dd></dl>

</div>
</div>
<a id="ae87045f6894f622664b4f8c0df15d96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87045f6894f622664b4f8c0df15d96b">&#9670;&nbsp;</a></span>LIBRARY_LINK_FUNCTION() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLU::LIBRARY_LINK_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">setExceptionDetailsContext&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LibraryLink function that <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> will call to set the context for the symbol, to which exception details are assigned. </p>
<p>This symbol is usually in the paclet's Private` context and it cannot be hardcoded in <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a>. </p>

</div>
</div>
<a id="a86cd388ae60de31cb8b3ef9678bbba06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cd388ae60de31cb8b3ef9678bbba06">&#9670;&nbsp;</a></span>LIBRARY_LINK_FUNCTION() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLU::LIBRARY_LINK_FUNCTION </td>
          <td>(</td>
          <td class="paramtype">setLoggerContext&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LibraryLink function that <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> will call to set the context for the symbol, to which log details are assigned. </p>
<p>This symbol is usually in the paclet's Private` context and it cannot be hardcoded in <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a>. </p>

</div>
</div>
<a id="a2c7dd018149857ca8efb5cb6ce51ff12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7dd018149857ca8efb5cb6ce51ff12">&#9670;&nbsp;</a></span>manageInstanceCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::manageInstanceCallback </td>
          <td>(</td>
          <td class="paramtype">WolframLibraryData&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mbool&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mint&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A template for library callback used by LibraryLink to manage instances of ManagedLibraryExpressions. </p>
<p>Specializations should typically just call manageInstance method from the <a class="el" href="classLLU_1_1ManagedExpressionStore.html" title="ManagedExpressionStore will keep track of instances of managed class T and will provide safe access t...">ManagedExpressionStore</a> corresponding to class T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- class to be managed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function must be explicitly specialized for any class that is supposed to be managed. Therefore instantiation of the general template will trigger compilation error. </dd></dl>

</div>
</div>
<a id="a2fe77f7de2bcfa22a61972162fcc4926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe77f7de2bcfa22a61972162fcc4926">&#9670;&nbsp;</a></span>openFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceLLU.html#a69b7b156baa9302492eb6a7b7cedf49a">FilePtr</a> LLU::openFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios::openmode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLLU_1_1SharePolicy.html">SharePolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>shp</em> = <code><a class="el" href="structLLU_1_1AlwaysReadExclusiveWrite.html">AlwaysReadExclusiveWrite</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open given file with specified mode (read, write, append, etc.). </p>
<p>Checks with WolframLibraryData if the path is "valid" (we don't know what that really means). Converts file name to UTF-16 wide string on Windows. Uses open modes from std::ios. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>- path to the input file </td></tr>
    <tr><td class="paramname">mode</td><td>- file open mode </td></tr>
    <tr><td class="paramname">shp</td><td>- shared access policy, only used on Windows. See <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/sharing-constants">https://docs.microsoft.com/en-us/cpp/c-runtime-library/sharing-constants</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to opened file </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a47e002b7f687731ed2a837961f202737" title="Could not open file.">ErrorName::OpenFileFailed</a></td><td>if the file could not be opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9016456b50c299c9bcefd407010a0488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9016456b50c299c9bcefd407010a0488">&#9670;&nbsp;</a></span>openFileStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::fstream LLU::openFileStream </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios::openmode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structLLU_1_1SharePolicy.html">SharePolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>shp</em> = <code><a class="el" href="structLLU_1_1AlwaysReadExclusiveWrite.html">AlwaysReadExclusiveWrite</a>&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file stream with specified mode (read, write, append, etc.). </p>
<p>Checks with WolframLibraryData if the path is "valid" (we don't know what that really means). Converts file name to UTF-16 wide string on Windows. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>- path to the input file </td></tr>
    <tr><td class="paramname">mode</td><td>- file open mode </td></tr>
    <tr><td class="paramname">shp</td><td>- shared access policy, only used on Windows. See <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/sharing-constants">https://docs.microsoft.com/en-us/cpp/c-runtime-library/sharing-constants</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Valid file stream </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespaceLLU_1_1ErrorName.html#a47e002b7f687731ed2a837961f202737" title="Could not open file.">ErrorName::OpenFileFailed</a></td><td>if the file could not be opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6507f4ce974332a965f18a6551d7b6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6507f4ce974332a965f18a6551d7b6c5">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; LLU::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLLU_1_1MArray.html">MArray</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insertion operator to allow pretty-printing of <a class="el" href="classLLU_1_1MArray.html" title="This is a class template, where template parameter T is the type of data elements....">MArray</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- type of elements in the container </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>- output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>- const&amp; to the <a class="el" href="classLLU_1_1MArray.html" title="This is a class template, where template parameter T is the type of data elements....">MArray</a> we want to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88589493c6a906a84503c7261590e00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88589493c6a906a84503c7261590e00d">&#9670;&nbsp;</a></span>sendRegisteredErrors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXTERN_C DLLEXPORT int LLU::sendRegisteredErrors </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] WolframLibraryData&#160;</td>
          <td class="paramname"><em>libData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WSLINK&#160;</td>
          <td class="paramname"><em>mlp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LibraryLink function that <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> will call to send all errors registered in C++ to the Wolfram Language layer. </p>
<p>This way <a class="el" href="namespaceLLU.html" title="Main namespace of LibraryLink Utilities.">LLU</a> is able to translate exceptions from C++ to appropriate Failure expressions in the Wolfram Language. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libData</td><td>- WolframLibraryData </td></tr>
    <tr><td class="paramname">mlp</td><td>- WSTP link to transfer data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code </dd></dl>

</div>
</div>
<a id="a9aedc692c1bacf554b1f141e16c669a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aedc692c1bacf554b1f141e16c669a9">&#9670;&nbsp;</a></span>Unused()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LLU::Unused </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dummy function called on otherwise unused parameters to eliminate compiler warnings. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>- variadic template parameter, any number of arbitrary types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa527ce949d7addf85262fd48c04159a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa527ce949d7addf85262fd48c04159a8">&#9670;&nbsp;</a></span>validatePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLU::validatePath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ios::openmode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the file <code>fileName</code> under open mode <code>mode</code> is accessible in the current sandbox setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileName</td><td>- file whose path is to be validated </td></tr>
    <tr><td class="paramname">mode</td><td>- file open mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85531f89f239a010ea002a6fb2611217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85531f89f239a010ea002a6fb2611217">&#9670;&nbsp;</a></span>variant_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VariantType , typename T , std::size_t index = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t LLU::variant_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get index of given type in the variant. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VariantType</td><td>- any variant type </td></tr>
    <tr><td class="paramname">T</td><td>- any type, if T is repeated in the variant, index of the first occurrence will be returned </td></tr>
    <tr><td class="paramname">index</td><td>- implementation detail, do not specify explicitly </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of given type in the variant or out-of-bound value if the type is not a variant member </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://stackoverflow.com/questions/52303316/get-index-by-type-in-stdvariant">https://stackoverflow.com/questions/52303316/get-index-by-type-in-stdvariant</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a526ba20abeaf0370d8b5cbbd2a058d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526ba20abeaf0370d8b5cbbd2a058d67">&#9670;&nbsp;</a></span>alwaysFalse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;MArgumentType T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool LLU::alwaysFalse = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper template variable that is always false. </p>
<p>Useful in meta-programming. </p>

</div>
</div>
<a id="a2d1a2c0ed927b6b294a3653be46640f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1a2c0ed927b6b294a3653be46640f6">&#9670;&nbsp;</a></span>dependent_false_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool LLU::dependent_false_v = <a class="el" href="structLLU_1_1dependent__false.html">dependent_false</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time boolean constant false that "depends" on a template parameter. </p>
<p>Useful utility for static_assert. </p>

</div>
</div>
<a id="a03f753d24e80a5fdb0a604de9b6df781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f753d24e80a5fdb0a604de9b6df781">&#9670;&nbsp;</a></span>has_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool LLU::has_size_v = has_size&lt;Container&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A type trait to check whether type <code>Container</code> has a member function <code>size()</code> </p>

</div>
</div>
<a id="aac859e1bc45cedcaa3017bc9cc039160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac859e1bc45cedcaa3017bc9cc039160">&#9670;&nbsp;</a></span>ImageType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr imagedata_t LLU::ImageType = MImage_Type_Undef</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility variable template that matches a C++ type with a corresponding MImage data type. </p>

</div>
</div>
<a id="afbc06f6339203269fdc77dfb2b15a499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc06f6339203269fdc77dfb2b15a499">&#9670;&nbsp;</a></span>is_iterable_container_with_matching_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool LLU::is_iterable_container_with_matching_type_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::conjunction&lt;std::is_class&lt;Container&gt;, has_value_type&lt;Container&gt;, is_iterable&lt;Container&gt;, has_matching_type&lt;Container, T&gt;&gt;::value</div>
</div><!-- fragment -->
<p>A type trait to check whether type <code>Container</code> is a class type with a member type alias <code>value_type</code> equal to T and with begin() and end() methods. </p>

</div>
</div>
<a id="a588365d600f8b9384e4006db8bafa98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588365d600f8b9384e4006db8bafa98a">&#9670;&nbsp;</a></span>NumericArrayType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr numericarray_data_t LLU::NumericArrayType = MNumericArray_Type_Undef</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility structure that matches a C++ type with a corresponding MNumericArray data type. </p>

</div>
</div>
<a id="a1bb7ca8417bb1bb81cf349c2f1f44e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb7ca8417bb1bb81cf349c2f1f44e97">&#9670;&nbsp;</a></span>TensorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mint LLU::TensorType = MType_Undef</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility structure that matches a C++ type with a corresponding MTensor data type. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceLLU.html">LLU</a></li>
    <li class="footer">Generated on Tue Oct 6 2020 23:12:12 for LibraryLink Utilities by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
